Instead of dumping the series-parallel tree decomposition of $\Gamma_{task}$ (or $\Gamma_{hybrid}$) to a functionnal high abstraction level language, or to an imperative high abstraction level language, such as OpenMP, we have chosen to dump it to a component model assembly. Component model is an interesting domain of software engineering~\cite{Szyperski:2002:CSB:515228} which improves code re-use, scalability and maintainability of applications~\cite{Szyperski:2002:CSB:515228,bigot:inria-00388508}. Moreover, component models bring a separation of concerns in the application by a clear division of functionnalities in different components.
Recent work on component models have shown a simultaneous answer to performance, maintainability and portability of application~\cite{l2c} which makes component models a serious and interesting candidate for modern high performance computing. 

Proposing a DSL which is dumped into a component assembly has many advantages:
\begin{itemize}
\item advantages of component models are inherited for the DSL itself. Thus, the DSL is easier to maintain, scalable, portable and still efficient; %a part portable, le reste devrait etre montrable dans evaluations
\item the DSL conception phase is improved because of code re-use and productivity; %SEQ,PAR,SSEQ peuvent etre utilises pour tout DSL
\item the DSL conception phase is facilitated by the separation of concerns in the set of components; %montrer assemblage, et les differentes preoccupations dans les differents composants
\item the DSL is light as its compiler generates a component assembly instead of code. %lié aussi a la separation de preoccupations, ce n'est pas au concepteur de DSL de gérer la generation de code, il utilise des composants qui peuvent etre codes par d'autres
\end{itemize}

%-------------------------------------
\subsection{Definitions}
%definir les trucs communs a tous les modeles a composants : composant, port (use, use-multiple, provide), interfaces, assemblages (descriptive, idl), connections valides

%certains modeles propose des concepts plus evolues tels que la hierarchie, la genericite, les connecteurs, 

%where an application is represented as a set of components, each of them responsible for a functionnality, and linked together through their interfaces. As a result, a component assembly represents the functional dependencies of the application. Each component is an independant black box, and one component could be replaced in the assembly by another one having same interfaces. Thus, component models 

%However, to obtain performance in applications, overheads introduced by separation of concerns of independant components, and their communications, have to be reduced as much as possible at runtime. For this reason, only two component models are nowadays considered as HPC-oriented: $L^2C$~\cite{l2c} and CCA~\cite{Allan04acomponent}. Both of them propose simple primitive components, and interactions between components are reduced to virtual method calls and MPI communications. The resulting component assembly, however, is close to the execution model and some components represent low level concerns which are as difficult to implement as standard HPC codes. A DSL hide those difficulties to the end-user while keeping advantages of component models.

%-------------------------------------
\subsection{Control components}

%-------------------------------------
\subsection{Transformation to a parallel assembly}