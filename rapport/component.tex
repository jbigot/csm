Instead of dumping the series-parallel tree decomposition of $\Gamma_{hybrid}$ (or $\Gamma_{task}$) to a functionnal high abstraction level language, or to an imperative high abstraction level language, such as OpenMP, we have chosen to dump it to a component model assembly. Component model is an interesting domain of software engineering~\cite{Szyperski:2002:CSB:515228} which improves code re-use, scalability and maintainability of applications~\cite{Szyperski:2002:CSB:515228,bigot:inria-00388508}. Moreover, component models bring a separation of concerns in the application by a clear division of functionnalities in different components.
Recent work on component models have shown a simultaneous answer to performance, maintainability and portability of application~\cite{l2c} which makes component models a serious and interesting candidate for maintainable modern high performance computing. 

Proposing a DSL which is dumped to a component assembly has many advantages:
\begin{itemize}
\item as for any DSL, the user manipulates a high-abstraction level language;
\item advantages of component models are inherited for the DSL itself. Thus, the DSL is easier to maintain, scalable, portable and still efficient; %a part portable, le reste devrait etre montrable dans evaluations
\item the DSL conception phase is improved because of code re-use and productivity; %SEQ,PAR,SSEQ peuvent etre utilises pour tout DSL
\item the DSL conception phase is facilitated by the separation of concerns; %montrer assemblage, et les differentes preoccupations dans les differents composants
\item the DSL is light as its compilation does not generate codes but a light component assembly. %lié aussi a la separation de preoccupations, ce n'est pas au concepteur de DSL de gérer la generation de code, il utilise des composants qui peuvent etre codes par d'autres
\end{itemize}

Component-based software engineering~\cite{Szyperski:2002:CSB:515228} extends the concept of class by specifying in its interfaces not only the services it offers, or public methods, but also all its possible interactions with outer world, including the services it requires. As a result, each component is an independant entity composed of a set of services its provides, and a set of services it requires (and uses). 

A \emph{port} is an entity embbedded in the component which makes possible an \emph{assembly} of components. An assembly of components (of instanciated components) is a way to actually connect components together and to produce a complete application, as a set of components and their interactions. An interface of provided services of a component is associated to a \emph{provide} port, while required services are associated to \emph{use} ports. It is also possible to group more than one required interface into a single port, as a list, called a \emph{use-multiple} port. As illustrated in Figures~\ref{fig:control}, a provide port will be represented by a white circle, a use port by a black circle and a use-multiple port by a black circle with a white $m$ in it.

Many component models exist, each of them with its particularities. However, components, ports, interfaces and assemblies are common concepts to all component models. The rest of this section will only use those concepts to define how the series-parallel tree decomposition, described in the previous Section, can be dumped to a component assembly, whatever the component model is.

%-------------------------------------
\subsection{Control-components}
As already explained, our aim is to dump the series-parallel tree decomposition of $\Gamma_{hybrid}$ to a component assembly. As a result, specific components have to be proposed such that $\mathcal{S}$ and $\mathcal{P}$ nodes of the decomposition can be associated to components. For this reason, we propose three specific \emph{control-components}. Those components are called control-components because they are used in a different way than usual components. Actually, as explained before, a component represents a precise functionnality of the application, while control-components represent a way to control the execution of components. Each control-component contains a single provide port, this port is associated to a single method which corresponds to the execution of the control-component.

\paragraph{Synchronization component.} A synchronization component, denoted $SYNC$, is a control-component for which the provided service is to garantee that an update of data is performed. A $SYNC$ component is thus composed of a single use-multiple port which will be connected to data to update.

\paragraph{Sequence component.} A sequence component, denoted $SEQ$, is a control-component for which the provided service is to garantee that the required services (provided by other components) are used one after the other in a precise order. Thus, the sequence component apply synchronous and ordered calls to required services. To do so, an ordered use-multiple port is needed.

\paragraph{Parallel component.} A parallel component, denoted $PAR$, is a control-component for which the provided service is to call simultaneously (asynchronously) a set of required services, and to wait the end of all asynchronous calls before terminating. Thus, $PAR$ is composed of a single use-multiple port which does not need to be ordered.

\begin{figure}[h!]
\captionsetup[subfigure]{labelformat=empty}

\begin{center}
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (sync) at (1.5,0) {$SYNC$};
   \node[provide] (p) at (0,0) {};
   \node[use] (u) at (1.5,1) {$m$};
 
  \path[->]
    (p) edge node {} (sync)
    (sync) edge node {} (u);
  \end{tikzpicture}
}
\end{center}
\hspace{50pt}

\begin{center}
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (seq) at (0,0) {$SEQ$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {$m$};
 
  \path[->]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
  \end{tikzpicture}
  }
  \end{center}
\hspace{50pt}

\begin{center}
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (seq) at (0,0) {$PAR$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {$m$};
 
  \path[->]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
  \end{tikzpicture}
}
\end{center}
\caption{$SEQ$, $SSEQ$ and $PAR$ control-components.}
\label{fig:control}
\end{figure}

\medskip
To be able to dump the series-parallel tree decomposition of $\Gamma_{hybrid}$ to a component assembly, each computation $c_i$ has to be associated to a component. Such a component contains a single provide port for which the service is to perform the computation. As a computation $c_i(R_i,w_i,\text{exp}_i)$ manipulates data $R$ and $w$, the component needs a use-multiple port to be linked to data.

\begin{figure}[h!]
\captionsetup[subfigure]{labelformat=empty}
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (c) at (0,0) {$c_i$};
   \node[provide] (p) at (-1,0) {};
   \node[use] (u) at (0,1) {$m$};
   \node[] (r) [right = 1cm of u] {$R_i \cup \{w_i\}$};
 
  \path[->]
    (p) edge node {} (c)
    (c) edge node {} (u);
  \end{tikzpicture}
  \caption{Computation component}
\label{fig:control}
\end{center}
\end{figure}

Use-multiple ports of $SEQ$ and $PAR$ can be equally linked in the assembly other control-components or to computation components.

%-------------------------------------
\subsection{Canonical series-parallel tree decomposition}
In the series-parallel binary tree decomposition of $\Gamma_{hybrid}$, $\mathcal{S}$ and $\mathcal{P}$ are binary operators. However, those operators could also accept more than two operands, resulting in less functionnal or component calls in the final dump, and thus to better performance. Moreover, definitions of $SEQ$ and $PAR$ are not binary (use-multiple).
In the work of Finta \& Al~\cite{Finta:1996:SUS:235643.235649}, a canonical form of the series-parallel binary tree decomposition has been introduced. The canonical form consists in merging two identical and successive compositions ($\mathcal{S}$ or $\mathcal{P}$) as a single one. %In the case of $\Gamma_{hybrid}$, however, a particular case appear when $\mathcal{S}$ is the source node of a leaf of updates $*_i$. In this case, it is forbidden to merge two sequence compositions $\mathcal{S}$. 
The canonical form of the final binary tree decomposition of Figure~\ref{fig:example}, is represented in Figure~\ref{fig:canon}.

\begin{figure}[h!]
\captionsetup[subfigure]{labelformat=empty}
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[] (s0) at (0,0) {$\mathcal{S}$};
   \node[] (c0) at (-3,1) {$c_0$};
   \node[] (star1) at (-2,1) {$*_1$};
   \node[] (c1) at (-1,1) {$c_1^*$};

   \node[] (p0) at (0,1) {$\mathcal{P}$};
   \node[] (s1) at (-1,2) {$\mathcal{S}$};
   \node[] (p1) at (-2,3) {$\mathcal{P}$};
   \node[] (c4) at (-1,3) {$c_4^*$};
   \node[] (c6) at (-0,3) {$c_6$};
   \node[] (c2) at (-2.5,4) {$c_2$};
   \node[] (star4) at (-1.5,4) {$*_4$};
   \node[] (s2) at (1,2) {$\mathcal{S}$};
   \node[] (c3) at (0.5,3) {$c_3$};
   \node[] (c5) at (1.5,3) {$c_5$};

   \node[] (c7) at (1,1) {$c_7$};
   \node[] (star8) at (2,1) {$*_8$};
   \node[] (c8) at (3,1) {$c_8^*$};
 
  \path[->]
    (s0) edge node {} (c0)
         edge node {} (star1)
         edge node {} (c1)
         edge node {} (p0)
         edge node {} (c7)
         edge node {} (star8)
         edge node {} (c8)
    (p0) edge node {} (s1)
         edge node {} (s2)
    (s1) edge node {} (p1)
         edge node {} (c4)
         edge node {} (c6)
    (p1) edge node {} (c2)
         edge node {} (star4)
    (s2) edge node {} (c3)
         edge node {} (c5);
  \end{tikzpicture}
\caption{Canonical form of the example of Figure~\ref{fig:example}.}
\label{fig:canon}
\end{center}
\end{figure}

From this canonical representation of the multi-stencil program $\mathcal{MSP}$, a direct dump to a component assembly is possible following the transformation rules of Figure~\ref{fig:dump}. One can note that this dump is possible because in the construction of the series-parallel tree decomposition, a node $*_i$ is by definition a leaf. As a result, $*_i$ can be mapped onto the control-component $SYNC$which has a single use-multiple port linked to the data (as the computation component).

\begin{figure}[h!]
\captionsetup[subfigure]{labelformat=empty}
\begin{center}
%SEQ RULE
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[] (x) at (0,0) {$\mathcal{S}$};
  \end{tikzpicture}
  }
\hspace{50pt}
%ARROW
\subfloat[]{
$\Rightarrow$
}
\hspace{50pt}
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (seq) at (0,0) {$SEQ$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {$m$};
 
  \path[->]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
\end{tikzpicture}
}
\\
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[] (x) at (0,0) {$\mathcal{P}$};
  \end{tikzpicture}
  }
\hspace{50pt}
\subfloat[]{
$\Rightarrow$
}
\hspace{50pt}
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (seq) at (0,0) {$PAR$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {$m$};
 
  \path[->]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
  \end{tikzpicture}
}
%SYNC
\\
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[] (y) at (0,0) {$*_i$};
  \end{tikzpicture}
  }
\hspace{50pt}
\subfloat[]{
$\Rightarrow$
}
\hspace{50pt}
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (sync) at (0,0) {$SYNC$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (0,1) {$m$};
   \node[] (r) [right = 0.5cm of u] {$R^*_i$};
 
  \path[->]
    (p) edge node {} (sync)
    (sync) edge node {} (u);
  \end{tikzpicture}
}
\caption{Direct dump rules from the canonical form to the component assembly.}
\label{fig:dump}
\end{center}
\end{figure}

For example, the canonical decomposition tree of Figure~\ref{fig:canon} is dumped into the component assembly of Figure~\ref{fig:assembly}. The text next to computation and synchronization components indicates to which data they have to be linked to. Actually, any computation $c_i$ or $c_i^*$ has to be linked to the data it reads and writes $R_i \cup w_i$. On the other hand, a synchronization $*_i$, has to be linked to the data it updates $R^*_i$.

\begin{figure}[h!]
\captionsetup[subfigure]{labelformat=empty}
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   %seq0
   \node[component] (seq0) at (0,0) {$SEQ$};
   \node[provide] (seq0p) [left = 1cm of seq0] {};
   \node[use] (seq0u) [right = 1cm of seq0] {$m$};
   %c0
   \node[component] (c0) [right = 2.5cm of seq0u] {$c_0$};
   \node[use] (c0u) [above = 0.8cm of c0] {$m$};
   \node[] (r0) [right = 1cm of c0u] {\textcolor{gray}{$R_0 \cup \{w_0\}$}};
   %sync0
   \node[component] (sync0) [below = 1.5cm of c0] {$SYNC$};
   \node[use] (sync0u) [above = 0.8cm of sync0] {$m$};
   \node[] (star1) [right = 0.5cm of sync0u] {\textcolor{gray}{$R^*_1$}};
   %c1
   \node[component] (c1) [below = 1.5cm of sync0] {$c_1^*$};
   \node[use] (c1u) [above = 0.8cm of c1] {$m$};
   \node[] (r1) [right = 1cm of c1u] {\textcolor{gray}{$R_1 \cup \{w_1\}$}};
   %par0
   \node[component] (par0) [below = 1cm of c1] {$PAR$};
   \node[use] (par0u) [right = 1cm of par0] {$m$};
  %seq1
   \node[component] (seq1) [right = 1cm of par0u] {$SEQ$};
   \node[use] (seq1u) [right = 1cm of seq1] {$m$};
   %par1
   \node[component] (par1) [right = 1cm of seq1u] {$PAR$};
   \node[use] (par1u) [right = 1cm of par1] {$m$};
  %c2
   \node[component] (c2) [right = 1.5cm of par1u] {$c_2$};
   \node[use] (c2u) [above = 0.8cm of c2] {$m$};
   \node[] (r2) [right = 1cm of c2u] {\textcolor{gray}{$R_2 \cup \{w_2\}$}};
  %sync1
   \node[component] (sync1) [below = 1.5cm of c2] {$SYNC$};
   \node[use] (sync1u) [above = 0.8cm of sync1] {$m$};
   \node[] (star4) [right = 0.5cm of sync1u] {\textcolor{gray}{$R^*_4$}};
  %c4
   \node[component] (c4) [below = 1.5cm of par1] {$c_4^*$};
   \node[use] (c4u) [above = 0.8cm of c4] {$m$};
   \node[] (r4) [right = 1cm of c4u] {\textcolor{gray}{$R_4 \cup \{w_4\}$}};
  %c6
   \node[component] (c6) [below = 1.5cm of c4] {$c_6$};
   \node[use] (c6u) [above = 0.8cm of c6] {$m$};
   \node[] (r6) [right = 1cm of c6u] {\textcolor{gray}{$R_6 \cup \{w_6\}$}};
  %seq2
   \node[component] (seq2) [below = 4.5cm of seq1] {$SEQ$};
   \node[use] (seq2u) [right = 1cm of seq2] {$m$};
  %c3
   \node[component] (c3) [right = 1cm of seq2u] {$c_3$};
   \node[use] (c3u) [above = 0.8cm of c3] {$m$};
   \node[] (r3) [right = 1cm of c3u] {\textcolor{gray}{$R_3 \cup \{w_3\}$}};
  %c5
   \node[component] (c5) [below = 1.5cm of c3] {$c_5$};
   \node[use] (c5u) [above = 0.8cm of c5] {$m$};
   \node[] (r5) [right = 1cm of c5u] {\textcolor{gray}{$R_5 \cup \{w_5\}$}};
  %c7
   \node[component] (c7) [below = 1.5cm of par0] {$c_7$};
   \node[use] (c7u) [above = 0.8cm of c7] {$m$};
   \node[] (r7) [right = 1cm of c7u] {\textcolor{gray}{$R_7 \cup \{w_7\}$}};
  %sync2
   \node[component] (sync2) [below = 1.5cm of c7] {$SYNC$};
   \node[use] (sync2u) [above = 0.8cm of sync2] {$m$};
   \node[] (star8) [right = 0.5cm of sync2u] {\textcolor{gray}{$R^*_8$}};
  %c8
   \node[component] (c8) [below = 1.5cm of sync2] {$c_8^*$};
   \node[use] (c8u) [above = 0.8cm of c8] {$m$};
   \node[] (r8) [right = 1cm of c8u] {\textcolor{gray}{$R_8 \cup \{w_8\}$}};

   \path[->]
   %seq0
    (seq0) edge node {} (seq0u)
    (seq0p) edge node {} (seq0)
   %c0
    (seq0u) edge node {} (c0)
    (c0) edge node {} (c0u)
    %sync0
    (seq0u) edge node {} (sync0.west)
    (sync0) edge node {} (sync0u)
    %c1
    (seq0u) edge node {} (c1)
    (c1) edge node {} (c1u)
   %par0
    (seq0u) edge node {} (par0.west)
    (par0) edge node {} (par0u)
  %seq1
    (par0u) edge node {} (seq1)
    (seq1) edge node {} (seq1u)
  %par1
    (seq1u) edge node {} (par1.west)
    (par1) edge node {} (par1u)
  %c2
    (par1u) edge node {} (c2)
    (c2) edge node {} (c2u)
  %sync0
    (par1u) edge node {} (sync1.west)
    (sync1) edge node {} (sync1u)
  %c4
    (seq1u) edge node {} (c4.west)
    (c4) edge node {} (c4u)
  %c6
    (seq1u) edge node {} (c6.west)
    (c6) edge node {} (c6u)
  %seq2
    (par0u) edge node {} (seq2.west)
    (seq2) edge node {} (seq2u)
  %c3
    (seq2u) edge node {} (c3)
    (c3) edge node {} (c3u)
  %c6
    (seq2u) edge node {} (c5.west)
    (c5) edge node {} (c5u)
  %c6
    (seq0u) edge node {} (c7.west)
    (c7) edge node {} (c7u)
  %sync2
    (seq0u) edge node {} (sync2.west)
    (sync2) edge node {} (sync2u)
  %c8
    (seq0u) edge [bend right] node {} (c8.west)
    (c8) edge node {} (c8u)
   ;
\end{tikzpicture}
\caption{Direct dump rules from the canonical form to the component assembly.}
\label{fig:assembly}
\end{center}
\end{figure}

%-------------------------------------
\subsection{Complete component assembly}
At this point of the work, the computation part $\Gamma$ of the parallel $\mathcal{MSP}$ program is solved and dumped to a component assembly. Of course, this component assembly does not represent the entire $\mathcal{MSP}$ program which also contains $\mathcal{M}$, $\Delta$ and $T$. Actually, additionnal services are needed. For example, computations are performed on quantities, or data, thus those data have to be accessible somewhere through services of components in the assembly. Those quantities are mapped onto a distributed mesh, which also means that the mesh has to be accessible by the data. In addition to this, and as explained in Section~\ref{sect:dataparal}, the data parallelization needs the management of specific update computations $*_i$, which means that the complete assembly have to manage an update service, as well as the partitioning of the mesh and the quantities mapped onto it.

to be continued...

%However, there is not a unique way to design the rest of the assembly and to make accessible the different services (data, update, mesh etc.). The work presented until now can be considered as a generic solution to solve the parallel computation part, but the rest of the assembly is dependant of the implementation choice. However, the implementation presented in this work, and detailed in the next Section, is inspired by the SIPSim model~\cite{} which is an interesting \emph{implicit parallelism model} to dump onto component models.