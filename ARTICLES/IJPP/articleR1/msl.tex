%----------------------------------------
\subsection{Generic Assembly}
%----------------------------------------
From the meta-model represented by Equation (~\ref{eq:msp}) the Generic Assembly (GA) of any multi-stencil program can be built. It is represented by Figure~\ref{fig:ga}. As illustrated, the GA has five different components described below.

\begin{figure}[t]
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component,fill=green!50!white] (D) at (0,0) {$Driver$};
   \node[provide] (Dp) at (-1,0) {};
   \node (Ds) at (-1.5,0) {start};
   \node[use,right=1.5cm of D] (Du1) {};
   \node[use,below=1.75cm of D] (Du2) {};
   \node[use,below=0.8cm of Du1] (Du3) {$m$};

   \node[provide,below=0.15 of Du2] (Tp) {};
   \node[component,below=1.6cm of Tp,fill=green!50!white] (T) {$Time$};
   \node[use,right=1cm of T] (Tu) {};
   \node[left=0.8cm of T] (tt) {$T$};

   \node[provide,right=0.15 of Tu] (Cp) {};
   \node[component, draw=blue!60!white,fill=green!50!white,text=blue!80!black,line width=0.5mm,right=2cm of Cp] (C) {$Computations$};
   \node[use,above=0.8cm of C] (Cu) {};
   \node[right=0.2cm of Cu] (star) {$*$};
   \node[right=1.5cm of C] (gamma) {$\Gamma$};

   \node[provide,below right=0.2 of Du3] (Datap1) {};
   \node[provide,above=0.15 of Cu] (Datap2) {};
   \node[component,double, draw=red,fill=red!50!white,above=0.8cm of Datap2] (Data) {$Data$};
   \node[use,above=0.8cm of Data] (Datau) {};
   \node[left=1cm of Data] (delta) {$\Delta$};
   \node[mpi,right=1cm of Data] (mpidata) {};
   \node[above=0.2cm of mpidata] (star2) {$*$};

   \node[provide,right=0.15 of Du1] (DDSp1) {};
   \node[provide,above=0.15 of Datau] (DDSp2) {};
   \node[component, draw=red, fill=red!50!white,above=0.8cm of DDSp2] (DDS) {$DDS$};
   \node[right=1.5cm of DDS] (m) {$\mathcal{M},\Phi,\mathcal{D},\mathcal{N}$};
 
  \path[-]
    (Dp) edge node {} (D)
    (D) edge node {} (Du1)
        edge node {} (Du2)
        edge node {} (Du3)
    (DDSp1) edge node {} (DDS)
    (Tp) edge node {} (T)
    (T)  edge node {} (Tu)
    (Cp) edge node {} (C)
    (C) edge node {} (Cu)
    (Datap2) edge node {} (Data)
    (Datap1) edge node {} (Data)
    (Data) edge node {} (Datau)
          edge node {} (mpidata)
    (DDSp2) edge node {} (DDS);
\end{tikzpicture}
\vspace*{.5em}
\caption{Generic Assembly according to the Multi-Stencil program formalism.}
\label{fig:ga}
\end{center}
\end{figure}

\paragraph{\textbf{Driver}}
This component can be compared to the main function of a usual program. It is responsible for both the initialization and the execution of other components (like variable initializations and function calls).

\paragraph{\textbf{Time}}
As indicated in the figure, this component is responsible for the time $T$ defined in Equation (~\ref{eq:msp}). Thus it is composed of a time loop and eventually of a convergence reduction.

\paragraph{\textbf{DDS}}
This component is responsible for the mesh and its entities $\mathcal{M}$, and $\Phi$, the computation domains $\mathcal{D}$ and the set of neighborhood functions $\mathcal{N}$. This component is generic, thus not typed. When GA will be instantiated and specialized by MSC, a specific type of mesh will replace this DDS meta-component. However, needed interfaces of such a DDS component are well known, and any component answering these interfaces can be indifferently used by MSF. A third party can propose new DDS components. In this paper, both data and task parallelism are used. In the case of data parallelism this component should handle mesh partitioning and should provide a synchronization interface as it will be detailed in Section~\ref{sect:parallelism}. One can note that this component is red, this means that this component should be provided by a HPC specialist in MSF as illustrated in the previous Figure~\ref{fig:msf}.

\paragraph{\textbf{Data}}
This component is inseparable from the previous one $DDS$. It actually uses the DDS component to instantiate one mesh variable. Thus, it is responsible for the set of mesh variables $\Delta$. This component is also red. As $DDS$ it should be provided by a HPC specialist. One can note that this component is represented by a double line box. This means that it can be instantiated multiple time while others will be instantiated once. Actually, this component will be instantiated as many times as the number of quantities in the simulation.

\paragraph{\textbf{Computations}}
Finally, this component is responsible for $\Gamma$, \ie the computations of the simulation. This component is green and blue because it will be partly generated by MSC and partly feeded by the developer. Actually, this component will be replaced by a sub-assembly of component, produced by MSC, for which the parallel part will be automatically generated. In this generated sub-assembly, components responsible for numerical codes will be completed by the developer. This sub-assembly generation is described in Section~\ref{sect:parallelism}.

%----------------------------------------
\subsection{The Multi-Stencil Language}
%----------------------------------------

The second element of MSF which is built upon the meta-model represented by Equation (~\ref{eq:msp}) is the Multi-Stencil Language and its grammar. This grammar is light and descriptive only, however it is sufficient (in addition to GA) for MSC to automatically extract a parallel pattern of the simulation, which is finally dumped as a specialized instantiation of GA.

\begin{filecontents*}{grammar.txt}
program ::= "mesh:" meshid 
            "mesh entities:" listgroup
            "computation domains:" listcompdom
            "independent:" listinde
            "stencil shapes:" liststencil
            "mesh quantities:" listquantities
            "scalars:" listscalar
            listloop

listgroup ::= groupid "," listgroup | groupid
listcompdom ::= compdom listcompdom | compdom
compdom ::= compdomid "in" groupid
listinde ::= inde listinde | inde
inde ::= compdomid "and" compdomid
liststencil ::= stencil liststencil | stencil
stencil ::= stencilid "from" groupid "to" groupid
listquantities ::= quantity listquantities |  quantity
quantity ::= groupid listquantityid
listquantityid ::= quantityid "," listquantityid |  quantityid
listscalar ::= scalarid "," listscalar | scalarid
listloop ::= loop listloop | loop
loop ::=  "time:" iteration
          "computations:" listcomp
iteration ::= num | scalarid
listcomp ::= comp listcomp |  comp
comp ::= written "=" compid "(" listread ")"
written ::= quantityid "[" compdomid "]" | scalar
listread ::= dataread listread | dataread
dataread ::= quantityid "[" stencilid "]" |  quantityid | scalar
\end{filecontents*}

\begin{figure}[hbt]
  \hspace{5mm}
  \begin{minipage}[!h]{0.98\textwidth}
    {\lstinputlisting[basicstyle=\small,mathescape,frame=single,language=Python,numbers=left]{grammar.txt}}   
    \caption{Grammar of the Multi-Stencil Language. \label{fig:grammar}}
  \end{minipage}
\end{figure}

The grammar of the Multi-Stencil Language is given in Figure~\ref{fig:grammar} and an example is provided in Figure~\ref{fig:exmsl}. A Multi-Stencil program is composed of eight parts as in Equation (~\ref{eq:msp}).

\begin{filecontents*}{exmsl.txt}
mesh : cart
mesh entities : cell, edgex
computation domains :
  d1 in cell
  d2 in edgex
independent :
  d1 and d2
stencil shapes : 
  ncc from cell to cell
  nce from cell to edgex
  nec from edgex to cell
mesh quantities :
  cell A,B,D,E,F,G,I,J
  edgex C,H
scalars : mu, tau
time : 500
computations :
  B[d1] = k0(tau,A)
  C[d2] = k1(B[nec])
  D[d1] = k2(C)
  E[d1] = k3(C)
  F[d1] = k4(D,C[nce])
  G[d1] = k5(mu,tau,E)
  H[d2] = k6(F)
  I[d1] = k7(G,H)
  J[d1] = k8(mu,I[ncc])
\end{filecontents*}

\begin{figure}[!h]
  \hspace{5mm}
  \begin{minipage}[!h]{0.98\textwidth}
    {\lstinputlisting[basicstyle=\small,mathescape,frame=single,language=Python,numbers=left]{exmsl.txt}}   
    \caption{Example of program using the Multi-Stencil Language. \label{fig:exmsl}}
  \end{minipage}
\end{figure}

\begin{enumerate}

\item The \texttt{mesh} keyword (Fig.\ref{fig:grammar},~l.1) introduces an identifier for $\mathcal{M}$, the single mesh of the simulation. For example \texttt{cart} in Fig.\ref{fig:exmsl},~l.1. The language, based on the meta-model (~\ref{eq:msp}), is independent of the mesh topology, thus this identifier is actually not used by the compiler but is syntactic sugar for the user.

\item The \texttt{mesh entities} keyword (Fig.\ref{fig:grammar},~l.2) introduces identifiers for the groups of entities $\mathcal{G}\in\Phi$. For example \texttt{cell} or \texttt{edgex} in Fig.\ref{fig:exmsl},~l.2. Again, this is syntactic sugar only as the compiler does not rely on the mesh topology.

\item The \texttt{computation domains} keyword (Fig.\ref{fig:grammar},~l.3) introduces identifiers for the computation domains $D\in\mathcal{D}$. For example \texttt{d1} and \texttt{d2} in Fig.\ref{fig:exmsl},~l.4-5. For reference, each domain is associated to a group of entities (Fig.\ref{fig:grammar},~l.12) such as \texttt{cell} for \texttt{d1} in Fig.\ref{fig:exmsl},~l.4.

\item The \texttt{independent} keyword (Fig.\ref{fig:grammar},~l.4) offers a way to declare that computation domains do not intersect, such as \texttt{d1} and \texttt{d2} in  Fig.\ref{fig:exmsl},~l.7. This is used by the compiler to compute dependencies between computations.

\item The \texttt{stencil shapes} keyword (Fig.\ref{fig:grammar},~l.5) introduces identifiers for $n\in\mathcal{N}$, the stencil shapes. For each shape, the source and destination group of entities (Fig.\ref{fig:grammar},~l.16) are specified. For example \texttt{nec} in Fig.\ref{fig:exmsl},~l.11 is a neighborhood from \texttt{edgex} to \texttt{cell}.

\item The \texttt{mesh quantities} keyword (Fig.\ref{fig:grammar},~l.6) introduces identifiers for $\delta\in\Delta$, the mesh variables with the group of entities they are mapped on (Fig.\ref{fig:grammar},~l.16). For example the quantities \texttt{C} and \texttt{H} are mapped onto \texttt{edgex} entities.

\item The \texttt{scalars} keyword (Fig.\ref{fig:grammar},~l.7) introduces identifiers for $s\in\mathcal{S}$, the scalars. For example \texttt{mu} and \texttt{tau} in Fig.\ref{fig:exmsl},~l.15. 

\item Finally, the last part (Fig.\ref{fig:grammar},~l.8) introduces the different computation loops of the simulation. Each loop is made of two parts:
\begin{itemize}
\item the \texttt{time} keyword (Fig.\ref{fig:grammar},~l.22) introduces $conv$, the convergence criteria either as a constant number of iterations or as a scalar variable (Fig.\ref{fig:grammar},~l.24). For example, 500 iterations are specified in Fig.\ref{fig:exmsl},~l.16,
\item the \texttt{computations} keyword (Fig.\ref{fig:grammar},~l.23) introduces identifiers for each computation $k\in\Gamma=(S,R,(w,D),comp)$. Each computation (Fig.\ref{fig:grammar},~l.26) specifies:
\begin{itemize}
 \item the quantity $w$ written and its domain $D$, for example in Fig.\ref{fig:exmsl},~l.22, kernel \texttt{k4} computes the quantity \texttt{F} on domain \texttt{d1},
 \item the read scalars $S$ and mesh quantities with their associated stencil shape $R$, for example in Fig.\ref{fig:exmsl},~l.16, \texttt{k4} reads \texttt{C} with the shape \texttt{nce} and \texttt{D} with the default \textit{identity} shape, it does not read scalars.
 \end{itemize}
\end{itemize}
\end{enumerate}

One can notice that in the example of Figure~\ref{fig:exmsl}, there are no (reduction) kernel associated to the scalars \texttt{mu} and \texttt{tau}.
In this case, those scalars are in fact constants.
One can also notice that the computation to execute for each kernel is not specified. Only an identifier is given to each kernel, for example $k_4$. The numerical code is indeed not handled by MSL, which is mesh-agnostic, and which is used to generate a parallel orchestration of computations only. The numerical computation is specified after MSC compilation by the developer (Fig.~\ref{fig:msf}).
