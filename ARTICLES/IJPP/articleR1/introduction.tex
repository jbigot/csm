\HC{has to be revised according to modifications}

As the computation power of modern high performance architectures increases, their heterogeneity and complexity also become more important. For example, the current world's top supercomputer Tianhe-2~\footnote{\url{www.top500.org}} is composed of multi-cores processors and accelerators, and is able to reach a theoretical peak performance around thirty peta floating point operations par seconds. However, to be able to use such a machine, multiple programming models, such as MPI (Message Passing Interface), OpenMP, CUDA etc., and multiple optimization techniques, such as cache or vectorization optimizations, have to be combined. Moreover, current architectures evolution lets think that heterogeneity and complexity in HPC will continue to grow in future.

One of the big challenges to solve to be able to use exascale computers is to propose programming models which gives access to high performance computing (HPC) to many scientists and not only to a few HPC specialists~\cite{ETP4HPC2013}. Actually, applications which run on supercomputers and which need such a computation power are physics, weather or genomic applications, which are not implemented by HPC specialists most of the time.

One possible runtime execution model for HPC is to propose dynamic scheduling of task graphs combined to message passing models~\cite{Gautier:2013:XRS:2510661.2511383,Augonnet2011,wu:hal-01078359} (to be able to use more than one machine). Those models increase HPC code portability and reach an interesting performance onto heterogeneous architectures, which is interesting to reach exascale programming. At a higher abstraction level, general purpose parallel languages, such as OpenMP~\cite{660313} and OpenCL~\cite{Stone:2010:OPP:622179.1803953} follow the direction of task graph scheduling proposed by those execution models. However, for non-experts end-users, general purpose languages still are difficult to use and to tune for a given application onto a given architecture. The current easiest (with the higher abstraction level), but still efficient, programming model for end-users is Domain Specific Language (DSL) and domain specific frameworks. Such solutions are specific to the end-user domain and propose a grammar or an API which is easy to understand. Moreover, the compiler is able, because of the specific knowledge onto the targeted domain, to automatically apply parallelization and specific optimization to produce a high performance back-end code. Thus, a domain specific solutions are able to split end-user concerns from HPC concerns which is relevant to reach exascale programming models.

However, many domain specific languages and frameworks have been proposed for many domains yet, and each one claims to solve a specific case that others don't. Furthermore instead of re-using a common basis for every language or framework of a same domain, each solution is implemented from scratch as a monolithic code. We claim in this paper that being able to find a common meta-model for all solutions of a given domain facilitates code re-use, and eases flexibility and maintainability of solutions. 

For example, to numerically solve a set of partial differential equations (PDEs), iterative methods are frequently used to approximate the exact solution through a discretized phenomena. A very well known and usual way to discretize PDEs is to transform them to explicit numerical schemes, also often called \emph{stencils}. Many DSLs have been proposed for stencil computations~\cite{spaaTangCKLL11,citeulike12258902,Ragan-Kelley:2013:HLC:2491956.2462176,DeVito:2011:LDS:2063384.2063396,Camier:2015:IPP:2820083.2820107}, as it will be detailed in Section~\ref{sect:rel}. Many of them use same kind of parallelization, data structures or optimization, however each one has been built from scratch to deal with another additional specific case. 

We propose the Multi-Stencil Framework (MSF) that is built over a meta-model of multi-stencil simulations. MSF produces a parallel orchestration of a multi-stencil program without being aware of the underlying implementation choices (\eg distributed data structures, task scheduler etc.). Thanks to this meta-model MSF is able to easily switch from one parallelization technique to another and from one optimization to another. Moreover, as the meta-model is independent from implementation details, MSF can easily choose one back-end or another, thus easing code reuse of existing solutions.

Contributions of the paper are: a meta-model of a multi-stencil program presented in Section~\ref{}; from this meta-model are built both a light and descriptive domain specific language MSL as well as a generic template of the application described in Section~\ref{}; the compiler MSC of the framework builds a parallel specialized version of the generic template from the specific application described with MSL; finally a performance evaluation is detailed in Section~\ref{}  and validates the performance model introduced in Section~\ref{}.

%as far as we know, only a few of them have been able to reuse work already done by another language~\cite{Sujeeth:2013:CRC:2524984.2524988}. In other words, software engineering properties have to be integrated into DSL conception, such that a new DSL can be seen as a composition of parallelization, optimizations or even languages semantics already proposed by others.
%For example, to numerically solve a set of partial differential equations (PDEs), iterative methods are frequently used to approximate the exact solution through a discretized phenomena. A very well known and usual way to discretize PDEs is to transform them to explicit numerical schemes, also often called \emph{stencils}. Many DSLs have been proposed for stencil computations~\cite{spaaTangCKLL11,citeulike12258902,Ragan-Kelley:2013:HLC:2491956.2462176,DeVito:2011:LDS:2063384.2063396,Camier:2015:IPP:2820083.2820107}, as it will be detailed in Section~\ref{sect:rel}. Many of them use same kind of parallelization, data structures or optimizations, however each one has been built from scratch to deal with another additionnal specific case.
%We present the Multi-Stencil Language (MSL) DSL, also for stencil-based numerical simulations. MSL is a language with a light grammar to describe a numerical simulation without implementation details. From the description, the compiler has enough information to extract and build an empty parallel pattern of the simulation, which can be filled, in a second step, by implementation concerns. The parallel pattern generated by the language is able to use different existing languages and libraries as it is independent from implementation choices. Moreover, the parallelization performed by the language is large enough to be compatible with many architectures and back-end languages. Contributions presented in this paper are : the computational model of a multi-stencil program and its parallelization formalism; the MSL grammar and its compiler; a back-end implementation and its performance evaluation onto a real case numerical simulation up to 16.384 cores.

%Section~\ref{sect:rel} introduces the related work on DSLs for stencils. Section~\ref{sect:formalism} formally explains the targetted domain and its computational model. From this model can be extracted the grammar of MSL in Section~\ref{sect:msl}. Section~\ref{sect:parallelism} shows how parallelism can be extracted from this light grammar of MSL. Sections~\ref{sect:msp} and~\ref{sect:comp} detail choices that have been done in this paper to evaluate MSL, and Section~\ref{sect:eval} shows performance results of the language. Finally, Section~\ref{sect:concl} concludes and proposes perspectives on this work.