%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% unifier texte avec nouvelle version article
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We have presented the Multi-Stencil Language (MSL), a domain specific language for stencil-based numerical simulations. Compared to other existing stencil DSLs, MSL proposes a higher abstraction level for end-users. MSL offers a way to describe a numerical simulation independently from the type of mesh used. As a result, the language can be used for a larger number of simulations. It helps to clearly separate the description of the simulation from implementation choices, which facilitates reuse of existing languages and libraries, for example languages for data structures optimizations and parallelization strategies. 

In this paper, the formal definition of a multi-stencil program has been given. This formalism helps to understand what is defined into the light grammar of MSL, and also how parallelization can be extracted from it. MSL produces an empty parallel pattern of the numerical simulation described. This pattern indicates where synchronizations are needed, but not how they are performed, which is dependent from the type of mesh and from implementation choices. This second step is left to other existing languages, which are chosen as a back-end of MSL. For example, in this paper the chosen back-end is a code using SkelGIS~\cite{CPE:CPE3494,DBLP:conf/ieeehpcs/HeleneS13,DBLP:conf/europar/CoullonL14}, a templated C++ language for distributed meshes (using MPI), and OpenMP~\cite{660313}.

Experiments presented in this paper show that the back-end code produced by MSL, \ie by a mesh-agnostic language, does not introduce overheads up to 16.384 cores, and that the hybrid (data and task) parallelism automatically introduced by the language, which combines SkelGIS and OpenMP as a back-end, improves performance compared to a data parallelization only. Thus, with the same code asked to the user, two different parallel versions of the simulation can be obtained.

However, if performances are improved by the hybrid parallelization, this performance is also limited by the scheduling strategy used in this paper. Actually, as described in Section~\ref{sect:msp}, a static series-parallel (fork-join) scheduling is performed in this work. This helps to define a predictive performance model, which has been validated in experiments. However, getting rid of global synchronizations (join) could be an interesting improvement to get better performance, especially for irregular simulations, where tasks are not naturally balanced. Our immediate perspective, thus, is to use OpenMP dynamic schedulers~\cite{Gautier:2013:XRS:2510661.2511383,Augonnet2011,wu:hal-01078359} as back-ends to study performance improvments. Using such dynamic schedulers also opens to more heterogeneous architectures, such as GPUs or many-cores accelerators.

Finally, to validate the separation of concerns introduced by MSL, a second back-end for unstructured meshes could be interesting. We think about PaMPA~\cite{lachat:hal-00768916} as a distributed data structure backend, instead of SkelGIS. Thus using a single language, the MSL language, two different kinds of numerical simulations could be defined: one onto Cartesian meshes; and one on unstructured meshes.

\HC{framework to ease HPC specialist work for proposing new meshes etc.}

