% orchestration of stencils, different from stencil compilers like Pochoir and PATUS which could be used inside MSF
Many domain specific languages have been proposed for the optimization of single stencil computations.
Each one has its own optimization specificities and targets a specific numerical method or a specific kind of mesh.
For example, Pochoir~\cite{spaaTangCKLL11} focuses on cache optimization techniques for stencils applied onto Cartesian meshes.
On the other hand, PATUS~\cite{citeulike12258902} proposes to add a parallelization strategy grammar to its stencil language to perform an auto-tuning parallelization strategies. Finally, ExaSlang~\cite{Schmitt:2014:EDL:2691166.2691171} is specific to multigrid numerical methods etc. Thus, these stencil compilers target a different scope than the Multi-Stencil Framework presented in this paper, which actually orchestrates a parallel execution of multiple stencil codes together. Furthermore, future works could lead to a combination of these stencil compilers with MSF to build very optimized stencil kernels $K$.

% Stencil orchestration
Some solutions, closer to MSF, have also been proposed to automatically orchestrate multiple stencils and computations in a parallel manner. Amongs them is Halide~\cite{Ragan-Kelley:2013:HLC:2491956.2462176} that proposes an optimization and parallelization of a pipeline of stencils. However, Halide is limited to Cartesian meshes and is specific to images. Liszt~\cite{DeVito:2011:LDS:2063384.2063396}, OP2~\cite{} and Nabla~\cite{Camier:2015:IPP:2820083.2820107} all offer solutions for the automatic parallel orchestration of stencils applied onto any kind of mesh, from Cartesian to unstructured meshes. The needed mesh can be built from a set of available symbols in the grammar of each language. Thus, these languages generalize the definition of a mesh, as it is proposed into the MSL formalism of Section~\ref{sect:formalism}. However, neither Liszt, OP2 nor Nabla handle hybrid parallelism as it is proposed by MSF.
\JB{Manque la ref OP2}

% MSF is not a general purpose framework. It proposes a new approach to improve sep. of concerns and code-reuse in Domain Specific Languages, by combining it to component generic assemblies.
MSF offers the MSL Domain Specific Language to the numerician to describe its sequential set of computations. This description, is close to a dataflow representation. However, MSL differs from general purpose dataflow languages or framework for two main reasons. First, MSL is specific to numerical simulations and proposes a mesh abstraction adapted to numerical simulations. Thus, compared to general purpose dataflow runtimes such as Legion~\cite{bauer:legion:sc:2012}, HPX~\cite{}, PFunc~\cite{}, MSL is closer to the semantic of the domain (mesh, stencils etc.) and easier to use for non-specialists. Second, MSL is very light and only descriptive. Numerical codes are left to another language and another user (the developer in Figure~\ref{fig:msf}). Furthermore, such dataflow runtimes could actually be used by MSF as backends, instead of using SkelGIS or OpenMP.
\JB{Manque de refs bis :)}

% vision of the framework brings separation of concerns, code-reuse and flexibility
This flexibility of MSF is due to software engineering capacities introduced by proposing a meta-model and by using component models. Actually, MSF is designed to increase separation of concerns and code-reuse compared to existing solutions.
%%%% sep of concerns
Separation of concerns is illustrated in Figure~\ref{fig:msf} and all along the paper. The numerician is only responsible for the description of the simulation by using MSL. A HPC specialist can propose new (or updated) components for handling the distributed data structure and quantities of the simulation. MSF generates from these informations the parallel orchestration of computations. Finally, after MSF compilation (MSC), the developer of numerical codes fills computation kernels by using the chosen distributed data structure. In Liszt, OP2 and Nabla, there is no such separation of concerns between the numerician and the developer. 
%%%% flexibility
Moreover, it is not possible to easily integrate a new distributed data structure in these solutions as a monolithic code is generated.
%%%% code-reuse
Finally, thanks to components, MSF improves code-reuse. Kernel components as well as any component (except the scheduler component which is specific to the simulation) can be reused from one simulation to another.

% no component-based framework for stencils orchestration (FFT, MapReduce/skeletons HLCM, nothing with DSLs)
To conclude and as far as we know, no component-based framework has been proposed for stencils orchestration.
