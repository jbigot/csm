%--------------------
\subsection{Overall compiler algorithm}

The overall compiler algorithm is represented in Algorithm~\ref{alg:compiler}. First, the parsing of the input file (written with the MSL language) gave enough information to build $\Gamma$, the ordered list of computations. Second, $\Gamma_{sync}$ and $\Gamma_{dep}$ can be built from $\Gamma$ using the recursive functions $F_{sync}$ and $F_{dep}$. Third, N-Shapes are removed from $\Gamma_{dep}$ to get a MSPD graph, and to be able to create its serie-parallel binary tree decomposition $TSP$ (line 6). Lines 7 to 9 are explained in the next section. Finally a dump of $TSP$ is performed by the compiler and will be described in Section~\ref{sect:eval}.

\begin{algorithm}
\caption{MSL Compiler}
\label{alg:compiler}
\begin{algorithmic}[1]
\Procedure{compileMSL} {file}
\State $\Gamma$ = parser(file)
\State $\Gamma_{sync} = F_{sync}(\Gamma,0)$
\State $\Gamma_{dep} = F_{dep}(\Gamma_{sync},0)$
\State removeNSH($\Gamma_{dep}$)
\State $TSP = BDT(L^{-1}(\Gamma_{dep}))$
\State $TSP = F_{tsp}(TSP,root(TSP))$
\If {data parallel}
\State $TSP = F_{tsp}(TSP)$
\EndIf
\State dump(TSP)
\EndProcedure
\end{algorithmic}
\end{algorithm}

%--------------------
\subsection{Canonical form and fusions}

The serie-parallel binary tree decomposition $TSP$ obtained from $BDT(L^{-1}(\Gamma_{dep}))$ can be reduced to its canonical form which consists in recursively merging successive $S$ vertices or successive $P$ vertices.

\medskip
\noindent \textbf{Definitions} For a tree $T(V,E)$
%\begin{mydef}
\begin{itemize}
\item we denote $root(T)$, the function which returns the root vertex of the tree $T$;
\item we denote $type(v)$ with $v \in V$ the function which returns the type of a vertex $v$. This type is either $S$, $P$, $comp$ or $sync$;
\item We denote $replace(E,v_1,v_2)$, the function which replaces for all edges of the set $E$, $v_1$ by $v_2$.
\end{itemize}

\begin{mydef}
We denote as a sequence or parallel sub-tree $T(V,E)$ sub-trees for which the root vertex respectively verifies $type(root(T))=S$ or $type(root(T))=P$.
\end{mydef}

\begin{myth}
\begin{itemize}
\item A sequence of sequence is a sequence if the order is kept. Thus for two sequence sub-trees $T_i$ and $T_j$, if $T_j \in V_i$, $T_i$ can be replaced by 
\begin{equation*}
T_i'(V_i \setminus root(T_j),E_i \cup replace(E_j,root(T_j),root(T_i)))
\end{equation*}
\item A parallel sub-tree of parallel sub-tree is a parallel sub-tree in any order. Thus for two parallel sub-trees $T_i$ and $T_j$, if $T_j \in V_i$, $T_i$ can be replaced by 
\begin{equation*}
T_i'(V_i \setminus root(T_j),E_i \cup replace(E_j,root(T_j),root(T_i)))
\end{equation*}
\end{itemize}
\end{myth}

These reductions applied recursively on the serie-parallel binary tree decomposition of $\Gamma_{dep}$ produce the canonical serie-parallel tree decomposition 
\begin{equation*}
TSP = F_{tsp}(TSP,root(TSP),successors(root(TSP)).
\end{equation*}
The recursive function $F_{tsp}$ is based on a Depth First Search algorithm and defined by Algorithm~\ref{alg:tsp}, where $E_{rooted(s)}$ represents the set of edges of the sub-tree rooted by the vertex $s$.

\begin{algorithm}
\caption{$F_{tsp}$}
\label{alg:tsp}
\begin{algorithmic}[1]
\Procedure{$F_{tsp}$} {$TSP$,root,succ}
\For {$s \in succ$}
\If {type($s$)=$S$ or type($s$)=$P$}
\State $F_{tsp}(TSP,s,successors(s))$
\If {type($s$)=type(root)}
\State $V_{tsp} = V_{tsp} \setminus s$
\State $E_{tsp} = E_{tsp} \cup replace(E_{rooted(s)},s,root)$
\State $TSP = (V_{tsp},E_{tsp})$
\EndIf
\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

Using MSL, it is possible to ask for data parallelization of the application, or for an hybrid parallelization. Even though the MSL language is not dedicated to produce very optimized stencil codes, but to produces the parallel pattern of the application, building the $TSP$ tree make available an easy optimization when the data parallelization technique is the only one used. This optimization consists in proposing a valid merge of some computation kernels inside a single space loop. As a result, the user can use this valid fusion of kernels or not when implementing those. The fusion function $F_{fus}$ is described in Algorithm~\ref{alg:fus}, where $parent(k)$ returns the parent vertex of $k$ in the tree, and where $k_{i;j}^{fus}$ represents the fusion of $k_i$ and $k_j$ keeping the sequential order $i;j$ if $i$ is computed before $j$ in $TSP$.

\begin{algorithm}
\caption{$F_{fus}$}
\label{alg:fus}
\begin{algorithmic}[1]
\Procedure{$F_{fus}$} {$TSP(V,E)$}
\For {$(k_i,k_j) \in V^2$}
\If {parent($k_i$)==parent($k_j$)}
\If {$type(k_i)=type(k_j)=comp$}
\If {parent($k_i$)==$S$}
\If {$D_i==D_j$}
\State propose the fusion $k_{i;j}^{fus}$
\EndIf
\ElsIf {parent($k_i$)==$P$}
\If {$D_i==D_j$ and $R_i \cap R_j \neq \emptyset$}
\State propose the fusion $k_{i;j}^{fus}$
\EndIf
\EndIf
\EndIf
\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

We are not arguing that such a simple fusion algorithm could be as good as complex cache optimization techniques which can be found in stencil DSLs for example~\cite{spaaTangCKLL11}. However, this fusion takes place at a different level and can bring performance improvments as it will be illustrated in Section~\ref{sect:eval}. This fusion algorithm relies on very simple statements:
\begin{itemize}
\item Two successive computation kernels $k_i$ and $k_j$ which are under the same parent vertex $S$ in TSP are, by construction, data dependant. As a result, what is written by the first one is read by the second one. Thus, at least one data is common to those computations (the one written by $k_i$). Thus, if the computation domains verify $D_i=D_j$, the fusion of $k_i$ and $k_j$ will decrease cache misses.
\item Two successive computation kernels $k_i$ and $k_j$ which are under the same parent vertex $P$ in TSP are not, by construction, data dependant. However, if the computation domains verify $D_i=D_j$, and if $R_i \cap R_j \neq \emptyset$ cache misses could also be decreased by the fusion $k_{i;j}^{fus}$.
\end{itemize}

%--------------------
\subsection{Overall example}

MSL code~\ref{fig:exmsl}. 
\begin{equation*}
\Gamma = [k_0,k_1,k_2,k_3,k_4,k_0,k_6,k_7,k_8]
\end{equation*}

\begin{equation*}
\Gamma_{sync} = [k_0,k_{0;1}^{sync},k_1,k_2,k_3,k_{1;4}^{sync},k_4,k_0,k_6,k_7,k_{7;8}^{sync},k_8]
\end{equation*}

where $k_{0;1}^{sync}$... 

$\Gamma_{dep}$~\ref{} and $L^{-1}(\Gamma_{dep})$~\ref{}

% Using those additional reduction rules, the binary series-parallel tree decomposition can be computed in linear time. 
A complete example of reduction is given in Figure~\ref{fig:example}. The initial $\Gamma_{hybrid}$ DAG and its inverse line graph are given first, followed by the set of reductions. The label of the final single edge corresponds to the binary tree decomposition of the initial $\Gamma_{hybrid}$ graph. 

%====BIG EXAMPLE
\begin{figure}[ht!]
\begin{center}
% INITIAL GRAPH
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[] (c0) at (0,0) {$k_0$};
   \node[] (star1) at (1,0) {$k_{0;1}^{sync}$};
   \node[] (c1) at (2,0) {$k_1$};
   \node[] (c2) at (3,0.5) {$k_2$};
   \node[] (star4) at (3,1.5) {$k_{1;4}^{sync}$};
   \node[] (c3) at (3,-0.5) {$k_3$};
   \node[] (c4) at (4,0.5) {$k_4$};
   \node[] (c5) at (4,-0.5) {$k_5$};
   \node[] (c6) at (5,0.5) {$k_6$};
   \node[] (c7) at (6,0) {$k_7$};
   \node[] (star8) at (7,0) {$k_{7;8}^{sync}$};
   \node[] (c8) at (8,0) {$k_8$};
 
  \path[->]
    (c0) edge node {} (star1)
    (star1) edge node {} (c1)
    (c1) edge node {} (c2)
         edge node {} (c3)
         edge node {} (star4)
    (star4) edge node {} (c4)
    (c2) edge node {} (c4)
    (c4) edge node {} (c6)
    (c3) edge node {} (c5)
    (c5) edge node {} (c7)
    (c6) edge node {} (c7)
    (c7) edge node {} (star8)
    (star8) edge node {} (c8);
  \end{tikzpicture}
}
\\
% INVERSE LINE GRAPH
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[circle,draw=black,fill=black,scale=0.3] (c0s) at (0,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c0d) at (1,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (star1d) at (2,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c1d) at (3,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c2d) at (4,0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c3d) at (4,-0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c4d) at (5,0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c6d) at (6,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c7d) at (7,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (star8d) at (8,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c8d) at (9,0) {};
 
  \path[->]
    (c0s) edge node [above] {$k_0$} (c0d)
    (c0d) edge node [above] {$k_{0;1}^{sync}$} (star1d)
    (star1d) edge node [above] {$k_1$} (c1d)
    (c1d) edge node [above] {$k_2$} (c2d)
          edge node [above] {$k_3$} (c3d)
          edge [bend left=80] node [above] {$k_{1;4}^{sync}$} (c2d)
    (c2d) edge node [above] {$k_4$} (c4d)
    (c4d) edge node [above] {$k_6$} (c6d)
    (c6d) edge node [above] {$k_7$} (c7d)
    (c7d) edge node [above] {$k_{7;8}^{sync}$} (star8d)
    (star8d) edge node [above] {$k_8$} (c8d)
    (c3d) edge node [above] {$k_0$} (c6d);
  \end{tikzpicture}
}
\end{center}
\caption{$\Gamma_{dep}$ and $L^{-1}(\Gamma_{dep})$}
\label{fig:dep}
\end{figure}

\begin{figure}[ht!]
\begin{center}
% TRANSFORMATIONS
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[circle,draw=black,fill=black,scale=0.3] (c0s) at (0,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c1d) at (3,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c2d) at (4,0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c3d) at (4,-0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c4d) at (5,0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c6d) at (6,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c8d) at (9,0) {};

   %reduction c0 c1
   \node[] (s0) at (1.5,0.5) {$\mathcal{S}$};
   \node[] (s1) at (1,1.5) {$\mathcal{S}$};
   \node[] (c0) at (0.5,2.5) {$k_0$};
   \node[] (star1) at (1.5,2.5) {$k_{0;1}^{sync}$};
   \node[] (c1) at (2,1.5) {$k_1$};
   
   %reduction c7 c8
   \node[] (s2) at (7.5,0.5) {$\mathcal{S}$};
   \node[] (s3) at (7,1.5) {$\mathcal{S}$};
   \node[] (c7) at (6.5,2.5) {$k_7$};
   \node[] (star8) at (7.5,2.5) {$k_{7;8}^{sync}$};
   \node[] (c8) at (8,1.5) {$k_8$};
 
  \path[->]
    (c0s) edge node {} (c1d)
    (c1d) edge node [above] {$k_2$} (c2d)
          edge node [above] {$k_3$} (c3d)
          edge [bend left=80] node [above] {$k_{1;4}^{sync}$} (c2d)
    (c2d) edge node [above] {$k_4$} (c4d)
    (c4d) edge node [above] {$k_6$} (c6d)
    (c6d) edge node [above] {} (c8d)
    (c3d) edge node [above] {$k_0$} (c6d)

    %reduction c0 c1
    (s0) edge node {} (s1)
         edge node {} (c1)
    (s1) edge node {} (c0)
         edge node {} (star1)
    %reduction c7 c8
    (s2) edge node {} (s3)
         edge node {} (c8)
    (s3) edge node {} (c7)
        edge node {} (star8);
  \end{tikzpicture}
}
\\
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[circle,draw=black,fill=black,scale=0.3] (c0s) at (0,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c1d) at (3,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c2d) at (4,0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c4d) at (5,0.5) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c6d) at (6,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c8d) at (9,0) {};

   %reduction c0 c1
   \node[] (s0) at (1.5,0.5) {$\mathcal{S}$};
   \node[] (s1) at (1,1.5) {$\mathcal{S}$};
   \node[] (c0) at (0.5,2.5) {$k_0$};
   \node[] (star1) at (1.5,2.5) {$k_{0;1}^{sync}$};
   \node[] (c1) at (2,1.5) {$k_1$};
   
   %reduction c7 c8
   \node[] (s2) at (7.5,0.5) {$\mathcal{S}$};
   \node[] (s3) at (7,1.5) {$\mathcal{S}$};
   \node[] (c7) at (6.5,2.5) {$k_7$};
   \node[] (star8) at (7.5,2.5) {$k_{7;8}^{sync}$};
   \node[] (c8) at (8,1.5) {$k_8$};

   %reduction c3 c5
   \node[] (s5) at (4.5,-2) {$\mathcal{S}$};
   \node[] (c3) at (4,-1) {$k_3$};
   \node[] (c5) at (5,-1) {$k_0$};

   %reduction c2 *4
   \node[] (p0) at (3.5,1) {$\mathcal{P}$};
   \node[] (c2) at (3,2) {$k_2$};
   \node[] (star4) at (4,2) {$k_{1;4}^{sync}$};
 
  \path[->]
    (c0s) edge node {} (c1d)
    (c1d) edge node [above] {} (c2d)
    (c2d) edge node [above] {$k_4$} (c4d)
    (c4d) edge node [above] {$k_6$} (c6d)
    (c6d) edge node [above] {} (c8d)
    (c1d) edge [bend right] node [above] {} (c6d)

    %reduction c0 c1
    (s0) edge node {} (s1)
         edge node {} (c1)
    (s1) edge node {} (c0)
         edge node {} (star1)
    %reduction c7 c8
    (s2) edge node {} (s3)
         edge node {} (c8)
    (s3) edge node {} (c7)
        edge node {} (star8)

    %reduction c3 c5
    (s5) edge node {} (c3)
         edge node {} (c5)

    %reduction c2 *4
    (p0) edge node {} (c2)
         edge node {} (star4);
  \end{tikzpicture}
}
\end{center}
\caption{Sequence and parallel rules applications}
\label{fig:SP}
\end{figure}

\begin{figure}[ht!]
\begin{center}
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[circle,draw=black,fill=black,scale=0.3] (c0s) at (0,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c1d) at (3,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c6d) at (6,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c8d) at (9,0) {};

   %reduction c0 c1
   \node[] (s0) at (1.5,0.5) {$\mathcal{S}$};
   \node[] (s1) at (1,1.5) {$\mathcal{S}$};
   \node[] (c0) at (0.5,2.5) {$k_0$};
   \node[] (star1) at (1.5,2.5) {$k_{0;1}^{sync}$};
   \node[] (c1) at (2,1.5) {$k_1$};
   
   %reduction c7 c8
   \node[] (s2) at (7.5,0.5) {$\mathcal{S}$};
   \node[] (s3) at (7,1.5) {$\mathcal{S}$};
   \node[] (c7) at (6.5,2.5) {$k_7$};
   \node[] (star8) at (7.5,2.5) {$k_{7;8}^{sync}$};
   \node[] (c8) at (8,1.5) {$k_8$};

   %reduction c3 c5
   \node[] (s5) at (4.5,-2) {$\mathcal{S}$};
   \node[] (c3) at (4,-1) {$k_3$};
   \node[] (c5) at (5,-1) {$k_0$};

   %reduction c2 c6
   \node[] (s6) at (4.5,1) {$\mathcal{S}$};
   \node[] (p0) at (3.5,2) {$\mathcal{P}$};
   \node[] (c2) at (3,3) {$k_2$};
   \node[] (star4) at (4,3) {$k_{1;4}^{sync}$};
   \node[] (s7) at (5.5,2) {$\mathcal{S}$};
   \node[] (c4) at (5,3) {$k_4$};
   \node[] (c6) at (6,3) {$k_6$};
 
  \path[->]
    (c0s) edge node {} (c1d)
    (c1d) edge [bend left] node [above] {} (c6d)
    (c6d) edge node [above] {} (c8d)
    (c1d) edge [bend right] node [above] {} (c6d)

    %reduction c0 c1
    (s0) edge node {} (s1)
         edge node {} (c1)
    (s1) edge node {} (c0)
         edge node {} (star1)
    %reduction c7 c8
    (s2) edge node {} (s3)
         edge node {} (c8)
    (s3) edge node {} (c7)
        edge node {} (star8)

    %reduction c3 c5
    (s5) edge node {} (c3)
         edge node {} (c5)

    %reduction c2 c6
    (s6) edge node {} (p0)
         edge node {} (s7)
    %reduction c2 *4
    (p0) edge node {} (c2)
         edge node {} (star4)
    (s7) edge node {} (c4)
         edge node {} (c6);
  \end{tikzpicture}
}
\\
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[circle,draw=black,fill=black,scale=0.3] (c0s) at (0,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c1d) at (3,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c6d) at (7,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c8d) at (9,0) {};

   %reduction c0 c1
   \node[] (s0) at (1.5,0.5) {$\mathcal{S}$};
   \node[] (s1) at (1,1.5) {$\mathcal{S}$};
   \node[] (c0) at (0.5,2.5) {$k_0$};
   \node[] (star1) at (1.5,2.5) {$k_{0;1}^{sync}$};
   \node[] (c1) at (2,1.5) {$k_1$};
   
   %reduction c7 c8
   \node[] (s2) at (7.5,0.5) {$\mathcal{S}$};
   \node[] (s3) at (7,1.5) {$\mathcal{S}$};
   \node[] (c7) at (6.5,2.5) {$k_7$};
   \node[] (star8) at (7.5,2.5) {$k_{7;8}^{sync}$};
   \node[] (c8) at (8,1.5) {$k_8$};

   \node[] (p1) at (4.5,0.5) {$\mathcal{P}$};
   %reduction c3 c5
   \node[] (s5) at (5.5,1.5) {$\mathcal{S}$};
   \node[] (c3) at (5,2.5) {$k_3$};
   \node[] (c5) at (6,2.5) {$k_0$};
   %reduction c2 c6
   \node[] (s6) at (3.5,1.5) {$\mathcal{S}$};
   \node[] (p0) at (2.8,2.5) {$\mathcal{P}$};
   \node[] (c2) at (2.3,3.5) {$k_2$};
   \node[] (star4) at (3.3,3.5) {$k_{1;4}^{sync}$};
   \node[] (s7) at (4.2,2.5) {$\mathcal{S}$};
   \node[] (c4) at (3.8,3.5) {$k_4$};
   \node[] (c6) at (4.8,3.5) {$k_6$};
 
  \path[->]
    (c0s) edge node {} (c1d)
    (c1d) edge node [above] {} (c6d)
    (c6d) edge node [above] {} (c8d)

    %reduction c0 c1
    (s0) edge node {} (s1)
         edge node {} (c1)
    (s1) edge node {} (c0)
         edge node {} (star1)
    %reduction c7 c8
    (s2) edge node {} (s3)
         edge node {} (c8)
    (s3) edge node {} (c7)
        edge node {} (star8)

    (p1) edge node {} (s6)
         edge node {} (s5)
    %reduction c3 c5
    (s5) edge node {} (c3)
         edge node {} (c5)
    %reduction c2 c6
    (s6) edge node {} (p0)
         edge node {} (s7)
    %reduction c2 *4
    (p0) edge node {} (c2)
         edge node {} (star4)
    (s7) edge node {} (c4)
         edge node {} (c6);
  \end{tikzpicture}
}
\\
\subfloat[]{
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[circle,draw=black,fill=black,scale=0.3] (c0s) at (0,0) {};
   \node[circle,draw=black,fill=black,scale=0.3] (c8d) at (9,0) {};

   \node[] (s8) at (4.5,0.5) {$\mathcal{S}$};
   \node[] (s9) at (3,1.5) {$\mathcal{S}$};

   %reduction c0 c1
   \node[] (s0) at (1.5,2.5) {$\mathcal{S}$};
   \node[] (s1) at (1,3.5) {$\mathcal{S}$};
   \node[] (c0) at (0.5,4.5) {$k_0$};
   \node[] (star1) at (1.5,4.5) {$k_{0;1}^{sync}$};
   \node[] (c1) at (2,3.5) {$k_1$};
   
   %reduction c7 c8
   \node[] (s2) at (7.5,1.5) {$\mathcal{S}$};
   \node[] (s3) at (7,2.5) {$\mathcal{S}$};
   \node[] (c7) at (6.5,3.5) {$k_7$};
   \node[] (star8) at (7.5,3.5) {$k_{7;8}^{sync}$};
   \node[] (c8) at (8,2.5) {$k_8$};

   \node[] (p1) at (4.5,2.5) {$\mathcal{P}$};
   %reduction c3 c5
   \node[] (s5) at (5.5,3.5) {$\mathcal{S}$};
   \node[] (c3) at (5,4.5) {$k_3$};
   \node[] (c5) at (6,4.5) {$k_0$};
   %reduction c2 c6
   \node[] (s6) at (3.5,3.5) {$\mathcal{S}$};
   \node[] (p0) at (2.8,4.5) {$\mathcal{P}$};
   \node[] (c2) at (2.3,5.5) {$k_2$};
   \node[] (star4) at (3.3,5.5) {$k_{1;4}^{sync}$};
   \node[] (s7) at (4.2,4.5) {$\mathcal{S}$};
   \node[] (c4) at (3.8,5.5) {$k_4$};
   \node[] (c6) at (4.8,5.5) {$k_6$};
 
  \path[->]
    (c0s) edge node {} (c8d)

    (s8) edge node {} (s9)
         edge node {} (s2)
    (s9) edge node {} (p1)
         edge node {} (s0)

    %reduction c0 c1
    (s0) edge node {} (s1)
         edge node {} (c1)
    (s1) edge node {} (c0)
         edge node {} (star1)
    %reduction c7 c8
    (s2) edge node {} (s3)
         edge node {} (c8)
    (s3) edge node {} (c7)
        edge node {} (star8)

    (p1) edge node {} (s6)
         edge node {} (s5)
    %reduction c3 c5
    (s5) edge node {} (c3)
         edge node {} (c5)
    %reduction c2 c6
    (s6) edge node {} (p0)
         edge node {} (s7)
    %reduction c2 *4
    (p0) edge node {} (c2)
         edge node {} (star4)
    (s7) edge node {} (c4)
         edge node {} (c6);
  \end{tikzpicture}
}
\end{center}
\caption{Rest of sequence and parallel rules.}
\label{fig:example}
\end{figure}

% At this point, the $\mathcal{MSP}$ program can be dumped to any parallel language in which a sequence and a parallel execution are available. For example, we could imagine a parallel functionnal language with a binary \emph{sequence} function and a binary \emph{parallel} function.