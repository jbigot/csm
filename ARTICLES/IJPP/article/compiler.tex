%--------------------
\subsection{Overall compiler algorithm}

The overall compiler algorithm is represented in Algorithm~\ref{alg:compiler}. First, the parsing of the input file (written with the MSL language) gave enough information to build $\Gamma$, the ordered list of computation kernels. Second, $\Gamma_{sync}$ and $\Gamma_{dep}$ can be built from $\Gamma$ using the recursive functions $F_{sync}$ and $F_{dep}$. Third, N-Shapes are removed from $\Gamma_{dep}$ to get a MSPD graph, and to be able to create its serie-parallel binary tree decomposition $TSP$ (line 6). If only a data parallelization has been chosen, Line 8 performs the fusion of kernels. Finally a dump of $TSP$ is performed by the compiler. Implementation choices of the dump are described in the next subsection.

\begin{algorithm}
\caption{MSL Compiler}
\label{alg:compiler}
\begin{algorithmic}[1]
\Procedure{compileMSL} {file}
\State $\Gamma$ = parser(file)
\State $\Gamma_{sync} = F_{sync}(\Gamma,0)$
\State $\Gamma_{dep} = F_{dep}(\Gamma_{sync},0)$
\State removeNSH($\Gamma_{dep}$)
\State $TSP = F_{tsp}(TSP,root(TSP))$
\If {data parallel}
\State $TSP = F_{fus}(TSP)$
\EndIf
\State dump(TSP)
\EndProcedure
\end{algorithmic}
\end{algorithm}

%--------------------
\subsection{Implementation choices}

The multi-stencil language is a descriptive language. MSL follows a light grammar which extracts information needed to build an empty parallel pattern of a numerical simulation (a multi-stencil program), also called an empty parallel skeleton of the simulation. From the language grammar are automatically detected where synchronizations are needed in order to apply a data parallelization technique, and how computations are dependent from each other to apply a task parallelization technique.

The multi-stencil language splits the simulation description from its implementation concerns. For this reason, the multi-stencil language is mesh-agnostic, which means that no information on the actual topology of the mesh is given by the user. For this reason too, no numerical code is asked to the user. Those implementation concerns are deported to a second phase where other languages or libraries can be used. This phase is called the \emph{dump} in the overall compiler algorithm.

In this paper, the MSL dump has been implemented using two existing languages, SkelGIS and OpenMP.

SkelGIS is a C++ embedded language~\cite{} which offers distributed data structures for numerical simulations, and programming interfaces to easily write codes using them. The code produced by SkelGIS uses MPI (message Passing Interface~\cite{}). Thus, this code can be used on distributed memory architectures such as clusters of machines. The distributed data structures offered by SkelGIS are, first, a distributed two dimensional Cartesian mesh~\cite{}, and second, a distributed graph of Cartesian meshes (hybrid mesh)~\cite{}. SkelGIS is used in this paper for the dump of MSL and more precisely to produce the code associated to the data parallelization technique.

OpenMP~\cite{} is a language based on directives added to C/C++ or Fortran. Those directives offers a way to take advantage of shared memory architectures such as multi-processors, multi-cores, many-cores or even GPUs (in OpenMP 4.0). Among other available directives, some of them offer the possibility to manage a pool of threads and to produce a task parallel program. In this paper OpenMP is used in its version 3.0, which means that we do not take advantage of the dynamic schedulers available for OpenMP 4.0 such as libgomp~\cite{}, StarPU~\cite{}, or XKaapi~\cite{}. Those dynamic schedulers will be the subject of future work. In this paper, however, is evaluated the performance of the static scheduling introduced in Section~\ref{sect:msp}.

The dump step of the MSL compiler automatically generates an hybrid code which uses the SkelGIS Cartesian distributed data structure and an OpenMP static scheduling generated from the algorithm previously described in Section~\ref{sect:tsp}. To facilitate the maintainability of this hybrid code, a component-based programming model is used, the Low Level Component Model~\cite{} (\llc). 

A component is a piece of code equivalent to a class in object-oriented programming, but which exposes not only provided methods, but also methods used from other components. Such programming models increase maintainability, productivity and code-reuse.

The advantage of using such models in MSL is to clearly separate the code responsible for data parallelization from the code responsible for the static scheduling of tasks. Moreover, one component is generated for each computation kernel which was described by the user in its MSL description. As a result, the user simply has to fill those components without any knowledge on the rest of the generated code. To fill its computation kernels, the user must use programming interfaces proposed by SkelGIS.

One can notice that MSL could use different languages as it is mesh-agnostic. For example, a future work is to use the distributed unstructured mesh proposed by PamPA~\cite{}. Moreover, MSL could use pthreads instead of OpenMP to manage the static scheduling.

