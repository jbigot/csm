Many domain specific languages have been proposed for stencil computations. Each one has its own specificities and answers to a specific stencil case or to a specific additionnal optimization. For example, Pochoir~\cite{spaaTangCKLL11} works on cache optimization techniques for stencils applied onto Cartesian meshes. On the other hand, PATUS~\cite{citeulike12258902} proposes to add a parallelization strategy grammar to its stencil language to perform an auto-tuning parallelization strategy. PATUS also works for stencils onto Cartesian meshes. Moreover, Halide~\cite{Ragan-Kelley:2013:HLC:2491956.2462176} works for Cartesian meshes, and proposes an optimization and parallelization of a pipeline of stencil codes. Finally, ExaSlang~\cite{Schmitt:2014:EDL:2691166.2691171} is specific to multigrid numerical methods.

The reason why each of those languages has its own particularities and its own optimizations is because each language is built and thought as a single block, which makes impossible or difficult code reuse from one language to another. Thus, each language starts from scratch to answer its own constraints. In other words domain specific languages (for stencils or other domains) suffer from a lack of software engineering properties, which could increase the productivity to build a new language, by code-reuse, and also the maintainability of languages, with more separation of concerns. The aim of the Mulsi-Stencil Language (MSL), presented in this paper, is to offer more separation of concerns, by splitting the description of a stencil-based numerical simulation, from its implementation concerns. As a result, MSL is mesh-agnostic and is able to reuse existing other languages (SkelGIS and OpenMP in this paper). 

Liszt~\cite{DeVito:2011:LDS:2063384.2063396} and Nabla~\cite{Camier:2015:IPP:2820083.2820107}, both offer languages for stencils applied onto any kind of mesh, from Cartesian to unstructured meshes. The mesh which is needed into the simulation can be built from a set of available symbols in the grammar of each language. Thus, those languages generalize the definition of a mesh, as it is proposed into the MSL formalism. 
However, two main differences can be noticed. First, the formalism is more flexible in MSL. For example, a computation can be applied onto a subset of the space domain which is not possible with Liszt and Nabla. This functionnality is an important flexibility in numerical simulations yet. For example, many computations performed in the simulation studied in this paper have to be applied onto a subpart of the overall space domain.
Second, in Liszt and Nabla the description of a simulation is not splitted from its implementation concerns. In other words, the topology of a mesh as well as numerical codes are given at the same time than the description of the different computations to apply into the simulation. 

MSL splits those two different phases of a simulation conception, which improves separation of concerns and maintainability of the simulation. As a result, a numerician could describes the different computations to perform into the simulation, while another one, later, could focuss on the implementation and the numerical code of the simulation. This also facilitates reuse of other languages. The formalism of a Multi-Stencil program, given in this paper, is new, as far as we know. Finally, the parallelization techniques proposed in this paper, take place at paradigm level, with data parallelism and hybrid (data plus task) parallelism. Thus those parallelization do not need details onto architectures (distributed or shared memories, with or without accelerators). This makes possible a large panel of backend architectures and languages.