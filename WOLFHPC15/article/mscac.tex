The solution presented in this paper contains a domain specific language to describe a multi-stencil program, i.e. an overall numerical simulation, and a compiler which successively parses the front-end language, transforms the internal representation, and finally dumps the representation to a back-end code.

The proposed DSL, called MSL, is an agnostic descriptive language for multi-stencil simulations. Agnostic means that the description of a numerical simulation does not depend on implementation constraints as, for example, the type of mesh (structured, unstructured) and its associated interfaces (how to define a stencil shape etc.). Descriptive, on the other hand, means that the terminal states of the language grammar are string identifiers. As a result, MSL is not made to handle the expression of numerical computations, but only the description of a multi-stencil simulation, in a coarse-grain fashion. In a MSL description, six main sections are defined, as the six tuples of the definition of a multi-stencil program $\mathcal{MSP}(T,\mathcal{M},\mathcal{D}_m,\mathcal{D}_c,\Delta,\Gamma)$.

As illustrated in Figure~\ref{fig:mscac}, the compiler, called MSCAC for \emph{Multi-Stencil Component Assembly Compiler}, is composed of three different phases. The first phase of the compiler is to \emph{parse} the MSL description. Second, the compiler analyzes and transforms the computation part of the description, in other words $\Gamma$, to an intermediate representation. This phase of compilation, called MSC, is responsible for the automatic parallelization of the overall numerical simulation. Finally, the parallel intermediate representation can be dumped to an actual implementation of the parallel structure of the simulation.

% As illustrated in Figure~\ref{fig:mscac}, the MS language compiler, called MSCAC for \emph{Multi-Stencil Component Assembly Compiler}, is composed of two different parts. First, the computation compiler, called \emph{MSC}, is responsible for the parallelization of computations and for its dump to a component assembly; second, the data compiler, called \emph{MSD}, handles a distributed data structure, data mapped onto it, and their relations with computations, as a final overall component assembly.
\begin{figure}[h!]
\begin{center}
\begin{tikzpicture}[remember picture,
  inner/.style={rectangle,rounded corners=3pt,thick,inner sep=5pt},
  outer/.style={rectangle,rounded corners=3pt,thick,inner sep=5pt}
  ]
  \node (MSL) {MS Language};
  \node[outer,below=0.5 of MSL,draw=black] (MSCAC) {
    \begin{tikzpicture}
      \node [inner,draw=black,thick] (pars)  {Parser};
      \node [inner,draw=black,thick,below=0.5cm of pars] (MSC)  {MSC};
      \node [inner,below=0.5cm of MSC,draw=black,thick] (Dump)  {Dump};

      \draw[->] (pars) -- (MSC);
      \draw[->] (MSC) -- (Dump);
    \end{tikzpicture}
  };
  \node [below=0.5 of MSCAC] (CA) {Component Assembly};
  \node [rotate=90,above left=0.5 of MSC] (CAid) {MSCAC};
  \draw[->] (MSL) -- (pars.north);
  \draw[->] (Dump.south) -- (CA);
\end{tikzpicture}
\caption{MSCAC compiler}
\label{fig:mscac}
\end{center}
\end{figure}

%In this paper are presented the language MSL, the MSC compilation phase, and the dump compilation phase. 
Parallelization techniques handled by MSC are \emph{data parallelism}, where data are splitted among processors or cores while applying a single program everywhere, and \emph{task parallelism} where the program is transformed into a dependency graph of tasks. From a dependency graph different strategies can be used to schedule tasks, in other words to control their execution in a valid order. The MSC compiler presented in this paper handles the transformation of the dependency graph to a static schedule of the tasks.

The final phase of compilation, the dump, uses the static schedule of the tasks, identified from $\Gamma$, and additionnal information on $T$, $\mathcal{M}$, $\Delta$, $\mathcal{D}_m$ and $\mathcal{D}_c$, from the \emph{parser}, to produce a back-end solution which represents the parallel pattern or skeleton of the overall simulation. We could have propose a dump to OpenMP~\cite{660313}, however this paper presents a first contribution to dump a DSL to a component-based runtime. Component models, where a component represents a clear and independent functionnality of the application, have first been proposed in Software engineering and have proved many times good properties for code re-use, separation of concerns, maintainability and productivity of codes. Those properties, on the other hand, are recurrent stated problems of parallel applications.

The back-end of the compiler is to build a parallel assembly of components, in other words appropriate connections between functionnalities of the numerical simulation. This assembly is illustrated in Figure~\ref{fig:assembly} which is explained in details in Section~\ref{sect:component}. As illustrated in the figure, each component is linked to one or more tuple of the multi-stencil program definition: \emph{DDS} component represents $\mathcal{M}$ and $\mathcal{D}_m$; \emph{Data} component represents $\Delta$ and $\mathcal{D}_c$; \emph{Time} component represents $T$, and \emph{Computations} component (which is generated by MSC) represents $\Gamma$.

The final back-end component assembly is a ready-to-fill parallel structure where the user has to write computation codes described in the MSL description. To write those computations, interfaces of the choosen implementation have to be used. For example, the back-end evaluated in this paper uses the distributed data structure proposed in SkelGIS library~\cite{CPE:CPE3494}, however a work in progress replaces this DDS component by another one using Global Arrays~\cite{Nieplocha:2006:AAP:1125980.1125985} data structure.

\begin{figure}
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (D) at (0,0) {$Driver$};
   \node[provide] (Dp) at (-1,0) {};
   \node (Ds) at (-1.5,0) {start};
   \node[use,right=1.5cm of D] (Du1) {};
   \node[use,below=0.8cm of D] (Du2) {};

   \node[provide,below=0.15 of Du2] (DAp) {};
   \node[component,below=0.8cm of DAp] (DA) {$DriverApp$};
   \node[use,right=1.7cm of DA] (DAu1) {$m$};
   \node[use,below=0.8cm of DA] (DAu2) {};

   \node[provide,below=0.15 of DAu2] (Tp) {};
   \node[component,below=0.8cm of Tp] (T) {$Time$};
   \node[use,right=1cm of T] (Tu) {};

   \node[provide,right=0.15 of Tu] (Cp) {};
   \node[component,right=2cm of Cp] (C) {$Computations$};
   \node[use,above=0.8cm of C] (Cu) {};
   \node[right=0.2cm of Cu] (star) {$*$};

   \node[provide,right=0.2 of DAu1] (Datap1) {};
   \node[provide,above=0.15 of Cu] (Datap2) {};
   \node[component,above=0.8cm of Datap2] (Data) {$Data$};
   \node[use,above=0.8cm of Data] (Datau) {};

   \node[provide,right=0.15 of Du1] (DDSp1) {};
   \node[provide,above=0.15 of Datau] (DDSp2) {};
   \node[component,above=0.8cm of DDSp2] (DDS) {$DDS$};
 
  \path[-]
    (Dp) edge node {} (D)
    (D) edge node {} (Du1)
        edge node {} (Du2)
    (DDSp1) edge node {} (DDS)
    (DA) edge node {} (DAu1)
           edge node {} (DAu2)
    (DAp) edge node {} (DA)
    (Tp) edge node {} (T)
    (T)  edge node {} (Tu)
    (Cp) edge node {} (C)
    (C) edge node {} (Cu)
    (Datap2) edge node {} (Data)
    (Datap1) edge node {} (Data)
    (Data) edge node {} (Datau)
    (DDSp2) edge node {} (DDS);
\end{tikzpicture}
\caption{Shape of the generated component assembly.}
\label{fig:assembly}
\end{center}
\end{figure}

% This paper presents the MS language and the MSC part of the compiler. The MSC compiler produces a static scheduling of the set of computations, ready to dump to a parallel language, such as OpenMP~\cite{660313} or HPF~\cite{219857}, but also ready to dump to a component assembly which is the main contribution of this work.

% \begin{figure*}
% \begin{center}
% \begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
%    \node[component] (D) at (0,0) {$Driver$};
%    \node[provide] (Dp) at (-1,0) {};
%    \node (Ds) at (-1.5,0) {start};
%    \node[use] (Du1) at (1,0.5) {};
%    \node[use] (Du2) at (1,-0.5) {};

%    \node[component,right=1cm of Du2] (DA) {$DriverApp$};
%    \node[use] (DAu1) at (3.5,0) {$m$};
%    \node[use] (DAu2) at (3.5,-1) {};

%    \node[component] (T) at (4.5,-1) {$Time$};
%    \node[use,right=1cm of T] (Tu) {};
%    \node[component,right=2cm of Tu] (C) {$Computations$};
%    \node[use,right=2cm of C] (Cu) {};
%    \node[below=0.2cm of Cu] (star) {$*$};

%    \node[component,right=8cm of DAu1] (Data) {$Data$};
%    \node[use,right=1cm of Data] (Datau) {};

%    \node[component,right=13cm of Du1] (DDS) {$DDS$};
 
%   \path[-]
%     (Dp) edge node {} (D)
%     (D.east) edge node {} (Du1)
%       edge node {} (Du2)
%     (Du1) edge node {} (DDS.west)
%     (Du2) edge node {} (DA)
%     (DA.east) edge node {} (DAu1)
%       edge node {} (DAu2)
%     (DAu1) edge node {} (Data.west)
%     (DAu2) edge node {} (T)
%     (T) edge node {} (Tu)
%     (Tu) edge node {} (C)
%     (C) edge node {} (Cu)
%     (Cu) edge node {} (Data.west)
%     (Data) edge node {} (Datau)
%     (Datau) edge node {} (DDS.west);
% \end{tikzpicture}
% \caption{Shape of the generated component assembly.}
% \label{fig:assembly}
% \end{center}
% \end{figure*}

% It has to be noticed that in this paper, the MSD compiler is a first adhoc version which works for a precise distributed data structure, the SkelGIS library~\cite{HeleneLS13,HeleneLS14,HeleneEuroPar14,CPE:CPE3494}. However, using the system of python string templates~\footnote{\url{https://docs.python.org/2/library/string.html}} to define the component assembly part which manages data, it is already possible to use another distributed data structure, as for example Global Arrays~\cite{Nieplocha:2006:AAP:1125980.1125985}. This part of the compiler takes place in a larger research project to propose domain decomposition skeletons using component models.

% The overall compiler MSCAC produces a ready-to-fill component-based parallel structure of the simulation. In this final component assembly, it is needed to write computation components, using interfaces of the distributed data structure choosen by MSD. Thus, this work is complementary to stencil compilers or to distributed data structure solutions.