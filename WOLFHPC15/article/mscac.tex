The solution proposed in this paper is based on \textbf{a)} a domain specific language to describe a multi-stencil program, \ie a complete numerical simulation, and \textbf{b)} a compiler which successively parses the language, applies transformations for automatic parallelization, and finally dumps the representation to a component-based code.

The proposed DSL, named MSL (\emph{Multi-Stencil Language}), is an agnostic descriptive language for multi-stencil simulations. Agnostic means that the description of a numerical simulation does not depend on implementation choices as, for example, the type of mesh (structured, unstructured), or its associated interfaces (how to define a stencil shape, etc.). Descriptive, on the other hand, means that MSL is not made to handle the expression of numerical computations, but only the description of a multi-stencil simulation, in a coarse-grain fashion. %Numerical computations are encapsulated in specific components that users have to develop. 
A MSL description is made of six main sections that match the six tuples elements of the definition of a multi-stencil program of Equation~\ref{eq:msp}.

\begin{figure}[t]
\begin{center}
\begin{tikzpicture}[remember picture,
  inner/.style={rectangle,rounded corners=3pt,thick,inner sep=5pt},
  outer/.style={rectangle,rounded corners=3pt,thick,inner sep=5pt}
  ]
  \node (MSL) {MSL};
  \node[outer,below=0.5 of MSL,draw=black] (MSCAC) {
    \begin{tikzpicture}
      \node [inner,draw=black,thick] (pars)  {Parser};
      \node [inner,draw=black,thick,below=0.5cm of pars] (MSC)  {MSC};
      \node [inner,below=0.5cm of MSC,draw=black,thick] (Dump)  {Dump};

      \draw[->] (pars) -- (MSC);
      \draw[->] (MSC) -- (Dump);
    \end{tikzpicture}
  };
  \node [below=0.5 of MSCAC] (CA) {Component-based runtime};
  \node [rotate=90,above left=0.5 of MSC] (CAid) {MSCAC};
  \draw[->] (MSL) -- (pars.north);
  \draw[->] (Dump.south) -- (CA);
\end{tikzpicture}
\caption{The three phases of the MSCAC compiler.}
\label{fig:mscac}
\end{center}
\end{figure}

As illustrated in Figure~\ref{fig:mscac}, the compiler, named MSCAC for \emph{Multi-Stencil Component Assembly Compiler}, is composed of three different phases. The first phase \emph{parses} the MSL description into an intermediate representation (IR). The second phase called MSC transforms the computation part ($\Gamma$) of the IR in order to automatically introduce parallelism in the overall numerical simulation.
Finally, the third phase dumps the IR to an actual implementation of the parallel pattern of the simulation.

% As illustrated in Figure~\ref{fig:mscac}, the MS language compiler, called MSCAC for \emph{Multi-Stencil Component Assembly Compiler}, is composed of two different parts. First, the computation compiler, called \emph{MSC}, is responsible for the parallelization of computations and for its dump to a component assembly; second, the data compiler, called \emph{MSD}, handles a distributed data structure, data mapped onto it, and their relations with computations, as a final overall component assembly.

%In this paper are presented the language MSL, the MSC compilation phase, and the dump compilation phase. 
The parallelization techniques handled by MSC are \emph{data parallelism}, where data is split among processors or cores while applying the same computation on every piece of data, and \emph{task parallelism} where the program is transformed into a graph of tasks with dependencies.
Different strategies can be used to schedule the tasks of this graph; in other words to plan their execution in a valid order. The MSC compiler presented in this paper handles the transformation of the dependency graph to a static scheduling.

The final phase of compilation, the dump, uses the static scheduling of the tasks, created from $\Gamma$, and additional information on $T$, $\mathcal{M}$, $\Delta$, $\mathcal{E}$ and $\mathcal{D}$.
It generates a program in the back-end language which embeds the parallel pattern or skeleton of the overall simulation.
Various models could be used as back-end, such as OpenMP~\cite{660313} for example, however this paper adopts a novel approach where the dump targets a component-based runtime.
This approach makes it possible to leverage good properties of software component models such as increased code re-use, eased separation of concerns, and increased maintainability and productivity.
% JB: la phrase en dessous est pas tres heureuse ...
Those properties counter some known limitations of DSLs. % JB: was "parallel applications".
%where a component represents a clear and independent functionality of the application, have first been proposed in software engineering and have proved many times good properties for 

Thanks to the software components based approach, the generated code is made of four independent parts that loosely match the elements of the multi-stencil program definition.
These are the components implementing: \textbf{a)} the computations scheduling ($\Gamma$), \textbf{b)} the data structures ($\mathcal{M}$ and $\mathcal{E}$), \textbf{c)} data of the simulation ($\Delta$ and $\mathcal{D}$), and \textbf{d)} the time loop ($T$). The actual implementation of the numerical expressions are provided by the user and used in the computations scheduling.
This component-based parallel structure enables to change the technology used for each part while limiting the impact on the other parts as further discussed in Section~\ref{sect:component}.

% This paper presents the MS language and the MSC part of the compiler. The MSC compiler produces a static scheduling of the set of computations, ready to dump to a parallel language, such as OpenMP~\cite{660313} or HPF~\cite{219857}, but also ready to dump to a component assembly which is the main contribution of this work.

% \begin{figure*}
% \begin{center}
% \begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
%    \node[component] (D) at (0,0) {$Driver$};
%    \node[provide] (Dp) at (-1,0) {};
%    \node (Ds) at (-1.5,0) {start};
%    \node[use] (Du1) at (1,0.5) {};
%    \node[use] (Du2) at (1,-0.5) {};

%    \node[component,right=1cm of Du2] (DA) {$DriverApp$};
%    \node[use] (DAu1) at (3.5,0) {$m$};
%    \node[use] (DAu2) at (3.5,-1) {};

%    \node[component] (T) at (4.5,-1) {$Time$};
%    \node[use,right=1cm of T] (Tu) {};
%    \node[component,right=2cm of Tu] (C) {$Computations$};
%    \node[use,right=2cm of C] (Cu) {};
%    \node[below=0.2cm of Cu] (star) {$*$};

%    \node[component,right=8cm of DAu1] (Data) {$Data$};
%    \node[use,right=1cm of Data] (Datau) {};

%    \node[component,right=13cm of Du1] (DDS) {$DDS$};
 
%   \path[-]
%     (Dp) edge node {} (D)
%     (D.east) edge node {} (Du1)
%       edge node {} (Du2)
%     (Du1) edge node {} (DDS.west)
%     (Du2) edge node {} (DA)
%     (DA.east) edge node {} (DAu1)
%       edge node {} (DAu2)
%     (DAu1) edge node {} (Data.west)
%     (DAu2) edge node {} (T)
%     (T) edge node {} (Tu)
%     (Tu) edge node {} (C)
%     (C) edge node {} (Cu)
%     (Cu) edge node {} (Data.west)
%     (Data) edge node {} (Datau)
%     (Datau) edge node {} (DDS.west);
% \end{tikzpicture}
% \caption{Shape of the generated component assembly.}
% \label{fig:assembly}
% \end{center}
% \end{figure*}

% It has to be noticed that in this paper, the MSD compiler is a first adhoc version which works for a precise distributed data structure, the SkelGIS library~\cite{HeleneLS13,HeleneLS14,HeleneEuroPar14,CPE:CPE3494}. However, using the system of python string templates~\footnote{\url{https://docs.python.org/2/library/string.html}} to define the component assembly part which manages data, it is already possible to use another distributed data structure, as for example Global Arrays~\cite{Nieplocha:2006:AAP:1125980.1125985}. This part of the compiler takes place in a larger research project to propose domain decomposition skeletons using component models.

% The overall compiler MSCAC produces a ready-to-fill component-based parallel structure of the simulation. In this final component assembly, it is needed to write computation components, using interfaces of the distributed data structure choosen by MSD. Thus, this work is complementary to stencil compilers or to distributed data structure solutions.
