The solution proposed in this paper contains a domain specific language to describe a multi-stencil program, \ie an overall numerical simulation, and a compiler which successively parses the front-end language, transforms the internal representation, and finally dumps the representation to a component-based back-end code.

The proposed DSL, named MSL (\emph{Multi-Stencil Language}), is an agnostic descriptive language for multi-stencil simulations. Agnostic means that the description of a numerical simulation does not depend on implementation choices as, for example, the type of mesh (structured, unstructured), or its associated interfaces (how to define a stencil shape, etc.). Descriptive, on the other hand, means that the terminal states of the language grammar are (string) identifiers. As a result, MSL is not made to handle the expression of numerical computations, but only the description of a multi-stencil simulation, in a coarse-grain fashion. %Numerical computations are encapsulated in specific components that users have to develop. 
In a MSL description, six main sections are defined, as the six tuples of the definition of a multi-stencil program of Equation~\ref{eq:msp}.

\begin{figure}[t]
\begin{center}
\begin{tikzpicture}[remember picture,
  inner/.style={rectangle,rounded corners=3pt,thick,inner sep=5pt},
  outer/.style={rectangle,rounded corners=3pt,thick,inner sep=5pt}
  ]
  \node (MSL) {MSL};
  \node[outer,below=0.5 of MSL,draw=black] (MSCAC) {
    \begin{tikzpicture}
      \node [inner,draw=black,thick] (pars)  {Parser};
      \node [inner,draw=black,thick,below=0.5cm of pars] (MSC)  {MSC};
      \node [inner,below=0.5cm of MSC,draw=black,thick] (Dump)  {Dump};

      \draw[->] (pars) -- (MSC);
      \draw[->] (MSC) -- (Dump);
    \end{tikzpicture}
  };
  \node [below=0.5 of MSCAC] (CA) {Component-based runtime};
  \node [rotate=90,above left=0.5 of MSC] (CAid) {MSCAC};
  \draw[->] (MSL) -- (pars.north);
  \draw[->] (Dump.south) -- (CA);
\end{tikzpicture}
\caption{The three phases of the MSCAC compiler.}
\label{fig:mscac}
\end{center}
\end{figure}

As illustrated in Figure~\ref{fig:mscac}, the compiler, named MSCAC for \emph{Multi-Stencil Component Assembly Compiler}, is composed of three different phases. The first phase of the compiler is to \emph{parse} the MSL description. Second, the compiler analyzes and transforms the computation part of the description $\Gamma$, to an intermediate representation. This phase of compilation, called MSC, is responsible for the automatic parallelization of the overall numerical simulation. Finally, the parallel intermediate representation is dumped to an actual implementation of the parallel pattern of the simulation.

% As illustrated in Figure~\ref{fig:mscac}, the MS language compiler, called MSCAC for \emph{Multi-Stencil Component Assembly Compiler}, is composed of two different parts. First, the computation compiler, called \emph{MSC}, is responsible for the parallelization of computations and for its dump to a component assembly; second, the data compiler, called \emph{MSD}, handles a distributed data structure, data mapped onto it, and their relations with computations, as a final overall component assembly.

%In this paper are presented the language MSL, the MSC compilation phase, and the dump compilation phase. 
The parallelization techniques handled by MSC are \emph{data parallelism}, where data are splitted among processors or cores while applying a single program everywhere, and \emph{task parallelism} where the program is transformed into a dependency graph of tasks. From a dependency graph, different strategies can be used to schedule tasks, in other words to control their execution in a valid order. The MSC compiler presented in this paper handles the transformation of the dependency graph to a static scheduling.

The final phase of compilation, the dump, uses the static schedule of the tasks, created from $\Gamma$, and additionnal information on $T$, $\mathcal{M}$, $\Delta$, $\mathcal{E}$ and $\mathcal{D}$, given by the \emph{parser}, to produce a back-end solution which represents the parallel pattern or skeleton of the overall simulation. We could have propose a dump to OpenMP~\cite{660313}, however this paper presents a first contribution to dump a DSL to a component-based runtime. Component models, where a component represents a clear and independent functionnality of the application, have first been proposed in software engineering and have proved many times good properties for code re-use, separation of concerns, maintainability and productivity of codes. Those properties, on the other hand, are recurrent stated problems of parallel applications.

The back-end of the compiler builds a component assembly, that can be divided in two parts: the components implementing the actual computation and the static schedule, and the components needed to manage it, \ie the runtime support. A general view of this assembly is proposed in Figure~\ref{fig:mscac:assembly}; it is explained in details in Section~\ref{sect:component}. As illustrated in the figure, each component is linked to one or more tuple of the multi-stencil program definition: \emph{DDS} component represents $\mathcal{M}$ and $\mathcal{E}$; \emph{Data} component represents $\Delta$ and $\mathcal{D}$; \emph{Time} component represents $T$, and \emph{Computations} component (which is generated by MSC) represents $\Gamma$.

The final back-end component assembly is a ready-to-fill parallel structure where the user has to write computation codes described in the MSL description. To write those computations, interfaces of the choosen implementation have to be used. For example, the back-end evaluated in this paper uses the distributed data structure proposed in SkelGIS library~\cite{CPE:CPE3494}. A work in progress replaces this DDS component by another one making use of Global Arrays~\cite{Nieplocha:2006:AAP:1125980.1125985}.

\begin{figure}[t]
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (D) at (0,0) {$Driver$};
   \node[provide] (Dp) at (-1,0) {};
   \node (Ds) at (-1.5,0) {start};
   \node[use,right=1.5cm of D] (Du1) {};
   \node[use,below=0.8cm of D] (Du2) {};

   \node[provide,below=0.15 of Du2] (DAp) {};
   \node[component,below=0.8cm of DAp] (DA) {$DriverApp$};
   \node[use,right=1.7cm of DA] (DAu1) {$m$};
   \node[use,below=0.8cm of DA] (DAu2) {};

   \node[provide,below=0.15 of DAu2] (Tp) {};
   \node[component,below=0.8cm of Tp] (T) {$Time$};
   \node[use,right=1cm of T] (Tu) {};
   \node[left=0.8cm of T] (tt) {$T$};

   \node[provide,right=0.15 of Tu] (Cp) {};
   \node[component,right=2cm of Cp] (C) {$Computations$};
   \node[use,above=0.8cm of C] (Cu) {};
   \node[right=0.2cm of Cu] (star) {$*$};
   \node[right=1.5cm of C] (gamma) {$\Gamma$};

   \node[provide,right=0.2 of DAu1] (Datap1) {};
   \node[provide,above=0.15 of Cu] (Datap2) {};
   \node[component,above=0.8cm of Datap2] (Data) {$Data$};
   \node[use,above=0.8cm of Data] (Datau) {};
   \node[right=1cm of Data] (delta) {$\Delta,\mathcal{D}$};

   \node[provide,right=0.15 of Du1] (DDSp1) {};
   \node[provide,above=0.15 of Datau] (DDSp2) {};
   \node[component,above=0.8cm of DDSp2] (DDS) {$DDS$};
   \node[right=1.2cm of DDS] (m) {$\mathcal{M},\mathcal{E}$};
 
  \path[-]
    (Dp) edge node {} (D)
    (D) edge node {} (Du1)
        edge node {} (Du2)
    (DDSp1) edge node {} (DDS)
    (DA) edge node {} (DAu1)
           edge node {} (DAu2)
    (DAp) edge node {} (DA)
    (Tp) edge node {} (T)
    (T)  edge node {} (Tu)
    (Cp) edge node {} (C)
    (C) edge node {} (Cu)
    (Datap2) edge node {} (Data)
    (Datap1) edge node {} (Data)
    (Data) edge node {} (Datau)
    (DDSp2) edge node {} (DDS);
\end{tikzpicture}
\caption{MSCAC Component Assembly Back-End Overview.}
\label{fig:mscac:assembly}
\end{center}
\end{figure}

% This paper presents the MS language and the MSC part of the compiler. The MSC compiler produces a static scheduling of the set of computations, ready to dump to a parallel language, such as OpenMP~\cite{660313} or HPF~\cite{219857}, but also ready to dump to a component assembly which is the main contribution of this work.

% \begin{figure*}
% \begin{center}
% \begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
%    \node[component] (D) at (0,0) {$Driver$};
%    \node[provide] (Dp) at (-1,0) {};
%    \node (Ds) at (-1.5,0) {start};
%    \node[use] (Du1) at (1,0.5) {};
%    \node[use] (Du2) at (1,-0.5) {};

%    \node[component,right=1cm of Du2] (DA) {$DriverApp$};
%    \node[use] (DAu1) at (3.5,0) {$m$};
%    \node[use] (DAu2) at (3.5,-1) {};

%    \node[component] (T) at (4.5,-1) {$Time$};
%    \node[use,right=1cm of T] (Tu) {};
%    \node[component,right=2cm of Tu] (C) {$Computations$};
%    \node[use,right=2cm of C] (Cu) {};
%    \node[below=0.2cm of Cu] (star) {$*$};

%    \node[component,right=8cm of DAu1] (Data) {$Data$};
%    \node[use,right=1cm of Data] (Datau) {};

%    \node[component,right=13cm of Du1] (DDS) {$DDS$};
 
%   \path[-]
%     (Dp) edge node {} (D)
%     (D.east) edge node {} (Du1)
%       edge node {} (Du2)
%     (Du1) edge node {} (DDS.west)
%     (Du2) edge node {} (DA)
%     (DA.east) edge node {} (DAu1)
%       edge node {} (DAu2)
%     (DAu1) edge node {} (Data.west)
%     (DAu2) edge node {} (T)
%     (T) edge node {} (Tu)
%     (Tu) edge node {} (C)
%     (C) edge node {} (Cu)
%     (Cu) edge node {} (Data.west)
%     (Data) edge node {} (Datau)
%     (Datau) edge node {} (DDS.west);
% \end{tikzpicture}
% \caption{Shape of the generated component assembly.}
% \label{fig:assembly}
% \end{center}
% \end{figure*}

% It has to be noticed that in this paper, the MSD compiler is a first adhoc version which works for a precise distributed data structure, the SkelGIS library~\cite{HeleneLS13,HeleneLS14,HeleneEuroPar14,CPE:CPE3494}. However, using the system of python string templates~\footnote{\url{https://docs.python.org/2/library/string.html}} to define the component assembly part which manages data, it is already possible to use another distributed data structure, as for example Global Arrays~\cite{Nieplocha:2006:AAP:1125980.1125985}. This part of the compiler takes place in a larger research project to propose domain decomposition skeletons using component models.

% The overall compiler MSCAC produces a ready-to-fill component-based parallel structure of the simulation. In this final component assembly, it is needed to write computation components, using interfaces of the distributed data structure choosen by MSD. Thus, this work is complementary to stencil compilers or to distributed data structure solutions.
