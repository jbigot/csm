Programming complex scientific applications on high performance heterogeneous architectures, such as clusters of multicores nodes containing accelerators, requires for the scientists to be an expert in his own domain, but also in low level parallel and high performance programming. It can take months to years for a scientist to learn HPC programming, as it is not his main activity. And while learning HPC programming, hardware continue to evolve, becoming more powerful but usually also more complex and difficult to use efficiently.

Domain Specific Languages (DSLs) are a promising solution to hide intricate details of HPC programming from non experts.
By being specific to a well-defined set of problems, these languages enable the generation of well parallelized and optimized code for various architectures while requiring only a limited amount of information from the developer; part of the knowledge is directly embedded in the compiler.
A critical question however concerns the specificity of DSLs.
Actually, the less specific the DSL is, the more information its users must provide and the less automatic optimizations can be embedded in the compiler.
%On the other side of the scope
Conversely, the more specific the DSL is, the less number of different applications can use it and the more difficult it is to amortize the implementation cost of the DSL (language, compiler, and runtime).
Programming difficulties, as well as non-maintainability and non-portability often seem to be simply deported from the scientist to DSL designers.
% Moreover, one can consider that end users need as much DSLs as domains, which keeps the amount of work to write and maintain up-to-date DSLs out of hands.

For this reason, solutions to ease the design and implementation of DSLs have recently appeared~\cite{Fernandez:2014:DFL:2691166.2691168}. The main idea of those solutions is to propose a single DSL to write new DSLs. In this paper, we study a first contribution to another approach to improve maintainability and portability in DSLs. This approach proposes a transformation from a DSL to a component-based runtime. Component-based Software Engineering have proved many times good properties for code re-use, separation of concerns, maintainability and productivity of codes. For this reason, we think that mixing DSLs and component-based runtimes could enable those properties, by inheritance, in DSLs.
To evaluate this approach, a proper new DSL for \emph{multi-stencil} programs, and its compiler are presented in this paper.
%\fix{cp2cp+hc: to dev benefits of components.}

Many solutions to automatically optimize and parallelize partial differential equations (PDEs) solvers have been proposed in the literature, either as specific libraries~\cite{petsc-efficient,Trilinos-Overview,CPE:CPE3494} or as DSLs~\cite{spaaTangCKLL11,citeulike12258902,Giles2011,DeVito2011LDS}. Most of the time, DSLs focus on the parallelization and the optimization of a single numerical computation, also called a stencil kernel.
However, a real case numerical simulation is most of the time not composed of a single stencil kernel, but of a set of stencil kernels and a set of additional local auxiliary computations. The DSL proposed in this paper, called MSL, is a DSL to generate a parallel component-based structure of an overall numerical simulation, that we call a \emph{multi-stencil program}. As it will be detailed in the related work, this is complementary to the optimization and parallelization of a single stencil kernel.

The rest of this paper is organized as follows. First, the concepts of \emph{stencil} and \emph{multi-stencil programs} are formalized in Section~\ref{sect:concept}. Section~\ref{sect:mscac} gives an overview of the solution presented in this paper while Section~\ref{sect:msmsc} details the MSL language and its compiler. Section~\ref{sect:component} introduces component models and describes the proposed component-based runtime and the automatic generation of its parallel computation part.
%The end of Section~\ref{sect:component} also discusses on interest of this new approach.
Section~\ref{sect:eval} focuses on a real-case simulation, solving the Shallow-water equations, and analyzes some performance results. Sections~\ref{sect:related} states on related work, and finally Section~\ref{sect:conclusion} concludes and gives some perspectives.
