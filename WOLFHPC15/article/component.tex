%----------------------------------------
\subsection{Overview}
%----------------------------------------

This section describes both the projection of $\Gamma_{tsp}$ to
components, and the remaining needed components to execute a
multi-stencil application. But, first the section gives an overview of
component models, and it details \llc, the component model used in
this work.


%----------------------------------------
\subsection{Component Model Overview}
%----------------------------------------
Component model is an domain of software
engineering~\cite{Szyperski:2002:CSB:515228}, which promotes code
re-use, separations of concerns, and thus maintainability. An
application is made by a set of component; a component being a kind of
black box that interacts only through ports: ports specify the
services provided and required.
%
With respect to high performance computing, some works have also shown
that component models can achieve the needed level of performance, and
scalability while also helping in application
portability~\cite{Bernholdt01052006, bigot:inria-00388508, UCHPC2015}

Many component models exist, each of them with its own specifications
and singularities. In distributed computing, well known component
models are CCM~\cite{corba:omg06} (CORBA Component Model), and
GCM~\cite{Baude} (Grid Component Model); in HPC, there are
CCA~\cite{Bernholdt01052006} (Common Component Architecture), and
\llc~\cite{l2c} (Low Level Component), for example.
%
As this work makes use of \llc, in particular for the experiments, let
describe it in more details.

%----------------------------------------
\subsection{\llc}
%----------------------------------------

\llc is a minimalist \texttt{C++} based HPC-oriented component model
where a component extends the concept of class by specifying in its
interfaces the services that it offers ($provide$ ports) and that it
needs, either a single service instance ($use$ ports), or multiple
service instances ($use-multiple$ ports). Services are \texttt{C++}
interfaces. \llc also offer $MPI$ ports that enable components to
share MPI communicators. Components can also have attribute ports to
be configured.
%
As illustrated in Figures~\ref{fig:ports}, a $provide$ port is
represented with a white circle on the left of the component, a $use$
port with a black circle, a $use-multiple$ port by a black circle with
a white $m$ in it, both on the right of the component. MPI port are
connected with a black rectangle.

A classical \llc-based application is a static \emph{assembly} of
components made of instances of components and of connections between
component ports. Such an assembly is described in LAD, an XML
dialect~\cite{l2c}.

\begin{figure}[t]
a)\hspace{2mm} \begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (C) at (0,0) {$C_0$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {};
   \node[provide,right=1.5cm of u] (p1) {};
   \node[component,right=1.5cm of p1] (C1) {$C_1$};
   \node[use,right=1.5cm of C1] (um) {$m$};
 
  \path[-]
    (p) edge node {$p$} (C)
    (C.east) edge node {$u$} (u)
    (C1)  edge node {$v$} (um)
    (p1) edge node {$q$} (C1);
\end{tikzpicture}
\\\\
b)\hspace{2mm}\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (C) at (0,0) {$C_0$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {};
   \node[component,right=1.5 of u] (C1) {$C_1$};
   \node[use,right=1.5 of C1] (um) {$m$};
 
  \path[-]
    (p) edge node {$p$} (C)
    (C) edge node {$u$} (u)
    (C1)  edge node {$v$} (um)
    (u) edge node {$q$} (C1);
\end{tikzpicture}
\\\\
c) \hspace{2mm}\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (C) at (0,0) {$C_2$};
   \node[provide] (p) at (-1.5,0) {};
   \node[mpi] (u) at (1.5,0) {};
   \node[component,right=1.5 of u] (C1) {$C_3$};
 
  \path[-]
    (p) edge node {$r$} (C)
    (C) edge node {$m_1$} (u)
    (u) edge node {$m_2$} (C1);
\end{tikzpicture}
\\\\
\caption{Example components and ports representation. a) Component $C_0$ has a provide port ($p$) and a use port ($u$); Component $C_1$ has also a provide port ($p'$) but a use multiple port ($u'$). b) A use port is connected to a (compatible) provide port. c) Component $C_2$ and $C_3$ shares an MPI communicator.}
\label{fig:ports}
\end{figure}

%% In the rest of this paper, when a required service of a \emph{use} (or \emph{use-multiple}) port is filled and linked to a \emph{provide} port in the comonent assembly, only the use port stay visible, as illustrated in Figure~\ref{fig:assembly}. As the use port is on the right of its component, and the provide port on the left, in a component assembly the component on the left uses the provide port of the component on the right.

%----------------------------------------
\subsection{MSCAC Runtime Overview}
%----------------------------------------

Figure~\ref{fig:assembly} has presented an overview of the component
assembly that is executed. As discusses in Section~\ref{sect:mscac},
there are different types of components. Components~\texttt{Driver},
\texttt{DriverApp}, and \texttt{Time} are always present; they do not
depend on the input but for the configuration of an attribute port of
Component~\texttt{Time} with the number of iterations. There is also a
single Component~\texttt{DDS} as in the current version only one mesh
type is supported. All these components are provided with the
compiler; dumping this part of the assembly is straightforward.

While Component~\texttt{DDS} is managing the structure of the mesh,
each data of the simulation is handled by a component of type
\texttt{Data}. Therefore, the compiler generates in the assembly as
many instances of such component as needed, from the \texttt{data}
section of an MSL program.

The last part of the assembly is the computations. It contains actual
computations in kernel components, denoted K, that have to be provided
to the compiler. A kernel component encapsulates a computations. To
access data, they are connected by the compiler to the adequate
\texttt{Data} components; their data ports name must respect the names
given in the \texttt{data} section of MSL. We denote the fact that they may have
several use port by adding a star on the use port:
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (k) at (0,0) {$K$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {};
   \node[right=0.2 of u] (star) {*};
 
  \path[-]
    (p) edge node {} (k)
    (k) edge node {} (u);
\end{tikzpicture}
\end{center}
  
%% In the computation part of the simulation a final component is needed,
%% the computation component, denoted K. This type of component
%% represents a single computation of the simulation, i.e. the
%% computation of a single output data (written) using a set of input
%% data (read). Using a \emph{use-multiple}, however, a list of component
%% is used and the explicit identification of each component to use is
%% lost. If for SEQ or PAR, the identification of components is not
%% usefull, it is usefull to manipulate data in a computation. For this
%% reason a computation component has as much \emph{use} ports as input
%% and output data to manipulate. We denote this in the bellow
%% representation as a star on the use port.



The computation part of the assembly also contains the static schedule
of the computations, \ie $\Gamma_{tsp}$. This is achieved by using
three specific components for managing the $P$, $S$, and $sync$
operations of $\Gamma_{tsp}$ as explained hereafter.

%----------------------------------------
\subsection{Control components}
%----------------------------------------
The series-parallel tree decomposition $\Gamma_{tsp}$ represents the
control of the dependencies of the simulation. As a result to be able
to dump it to a component assembly it is needed to introduce what can
be called \emph{control components}. Those components can be used for
any case of simulation which increases code reuse between
simulations. A control component is composed of a single
\emph{provide} port linked to a single execution method, most of the
time called the \emph{go} method. We introduce three types of control
components, whole graphical representation is given in Figure~\ref{fig:ctrlcomponents}.

\begin{figure}[t]
\begin{tikzpicture}[shorten >=1pt, node distance=1cm, on grid, auto]
   \node[component] (seq) at (0,0) {$SEQ$}; \node[provide] (p) at
   (-1,0) {}; \node[use] (u) at (1,0) {$m$};
 
  \path[-]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
\end{tikzpicture}
\hspace{\fill}
\begin{tikzpicture}[shorten >=1pt, node distance=1cm, on grid, auto]
   \node[component] (seq) at (0,0) {$PAR$};
   \node[provide] (p) at (-1,0) {};
   \node[use] (u) at (1,0) {$m$};
 
  \path[-]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
\end{tikzpicture}
\hspace{\fill}
\begin{tikzpicture}[shorten >=1pt, node distance=1cm, on grid, auto]
   \node[component] (sync) at (0,0) {$SYNC$};
   \node[provide] (p) at (-1,0) {};
   \node[use] (u) at (1,0) {};
 
  \path[-]
    (p) edge node {} (sync)
    (sync) edge node {} (u);
\end{tikzpicture}
\\
a) Comp. SEQ
\hspace{\fill}
b) Comp. PAR
\hspace{\fill}
c) Comp. SYNC
\\
\caption{The three control components used by the back-end.}
\label{fig:ctrlcomponents}
\end{figure}

\begin{description}
\item[Sequence component (SEQ)] It is the direct representation of a sequence node of $\Gamma_{tsp}$. The role of this component is to call an ordered list of other components. Its interface contains an ordered \emph{use-multiple} port to be connected to the components to call in sequence.

\item[Parallel component (PAR)] It is the direct representation of a parallel node of $\Gamma_{tsp}$. The role of this component is to call simultaneously a set of other components. It offers a \emph{use-multiple} port to be connected to the components to call in parallel.
  
\item[Synchronization component (SYNC)]. It is the direct representation to an update leaf of $\Gamma_{tsp}$. The role of this component is to call the synchronization of a given data. It offers an \emph{use} port to be connected to the data to update.

\end{description}


%----------------------------------------
\subsection{Dump to a component assembly}
%----------------------------------------
From $\Gamma_{tsp}$ and using the control components described above,
a direct dump can be done to a component assembly for an hybrid (data
and task) parallelization of a simulation. However, it is also
possible to dump to a data parallelization only. In such a case the
computation of $\Gamma_{data}$ is enough to generate the component
assembly. Actually a single SEQ component is thus needed and this
component is linked to all computations and synchronizations of
$\Gamma_{data}$ directly.

Figure~\ref{fig:assembly} displays the assembly part corresponding to
$\Gamma_{tsp}$ of Figure~\ref{fig:tsp}. In this figure, the ports
linked to data (use and use-multiple ports of SYNC and K) are
represented but are not connected. Moreover, each computation
component is an instance of the component K presented before but takes
the identification name of the computation in the MSL file.

\begin{figure*}[t]
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   %seq0
   \node[component] (seq0) at (0,0) {$SEQ$};
   \node[provide] (seq0p) [left = 0.8cm of seq0] {};
   \node[use] (seq0u) [right = 1cm of seq0] {$m$};
   %c0
   \node[component] (c0) [right = 2cm of seq0u] {$c_0$};
   \node[use] (c0u) [right = 0.8cm of c0] {};
   \node[right=0.2 of c0u] (star) {*};
   %sync0
   \node[component] (sync0) [below = 1cm of c0] {$SYNC$};
   \node[use] (sync0u) [right = 1cm of sync0] {$m$};
   %c1
   \node[component] (c1) [below = 0.8cm of sync0] {$c_1^*$};
   \node[use] (c1u) [right = 0.8cm of c1] {};
   \node[right=0.2 of c1u] (star) {*};
   %par0
   \node[component] (par0) [below = 0.8cm of c1] {$PAR$};
   \node[use] (par0u) [right = 1cm of par0] {$m$};
  %seq1
   \node[component] (seq1) [right = 1cm of par0u] {$SEQ$};
   \node[use] (seq1u) [right = 1cm of seq1] {$m$};
   %par1
   \node[component] (par1) [right = 1cm of seq1u] {$PAR$};
   \node[use] (par1u) [right = 1cm of par1] {$m$};
  %c2
   \node[component] (c2) [right = 1cm of par1u] {$c_2$};
   \node[use] (c2u) [right = 0.8cm of c2] {};
   \node[right=0.2 of c2u] (star) {*};
  %sync1
   \node[component] (sync1) [below = 0.8cm of c2] {$SYNC$};
   \node[use] (sync1u) [right = 1cm of sync1] {$m$};
  %c4
   \node[component] (c4) [below = 0.8cm of par1] {$c_4^*$};
   \node[use] (c4u) [right = 0.8cm of c4] {};
   \node[right=0.2 of c4u] (star) {*};
  %c6
   \node[component] (c6) [below = 0.8cm of c4] {$c_6$};
   \node[use] (c6u) [right = 0.8cm of c6] {};
   \node[right=0.2 of c6u] (star) {*};
  %seq2
   \node[component] (seq2) [below = 2.5cm of seq1] {$SEQ$};
   \node[use] (seq2u) [right = 1cm of seq2] {$m$};
  %c3
   \node[component] (c3) [right = 1cm of seq2u] {$c_3$};
   \node[use] (c3u) [right = 0.8cm of c3] {};
   \node[right=0.2 of c3u] (star) {*};
  %c5
   \node[component] (c5) [below = 0.8cm of c3] {$c_5$};
   \node[use] (c5u) [right = 0.8cm of c5] {};
   \node[right=0.2 of c5u] (star) {*};
  %c7
   \node[component] (c7) [below = 0.8cm of par0] {$c_7$};
   \node[use] (c7u) [right = 0.8cm of c7] {};
   \node[right=0.2 of c7u] (star) {*};
  %sync2
   \node[component] (sync2) [below = 0.8cm of c7] {$SYNC$};
   \node[use] (sync2u) [right = 1cm of sync2] {$m$};
  %c8
   \node[component] (c8) [below = 0.8cm of sync2] {$c_8^*$};
   \node[use] (c8u) [right = 0.8cm of c8] {};
   \node[right=0.2 of c8u] (star) {*};

   \path[-]
   %seq0
    (seq0) edge node {} (seq0u)
    (seq0p) edge node {} (seq0)
   %c0
    (seq0u) edge node {} (c0)
    (c0) edge node {} (c0u)
    %sync0
    (seq0u) edge node {} (sync0.west)
    (sync0) edge node {} (sync0u)
    %c1
    (seq0u) edge node {} (c1)
    (c1) edge node {} (c1u)
   %par0
    (seq0u) edge node {} (par0.west)
    (par0) edge node {} (par0u)
  %seq1
    (par0u) edge node {} (seq1)
    (seq1) edge node {} (seq1u)
  %par1
    (seq1u) edge node {} (par1.west)
    (par1) edge node {} (par1u)
  %c2
    (par1u) edge node {} (c2)
    (c2) edge node {} (c2u)
  %sync0
    (par1u) edge node {} (sync1.west)
    (sync1) edge node {} (sync1u)
  %c4
    (seq1u) edge node {} (c4.west)
    (c4) edge node {} (c4u)
  %c6
    (seq1u) edge node {} (c6.west)
    (c6) edge node {} (c6u)
  %seq2
    (par0u) edge node {} (seq2.west)
    (seq2) edge node {} (seq2u)
  %c3
    (seq2u) edge node {} (c3)
    (c3) edge node {} (c3u)
  %c6
    (seq2u) edge node {} (c5.west)
    (c5) edge node {} (c5u)
  %c6
    (seq0u) edge node {} (c7.west)
    (c7) edge node {} (c7u)
  %sync2
    (seq0u) edge node {} (sync2.west)
    (sync2) edge node {} (sync2u)
  %c8
    (seq0u) edge [bend right] node {} (c8.west)
    (c8) edge node {} (c8u)
   ;
\end{tikzpicture}
\caption{Component assembly representing the computation part generated from $\Gamma_{tsp}$ of Figure~\ref{fig:tsp}.}
\label{fig:assembly}
\end{center}
\end{figure*}

%----------------------------------------
