%----------------------------------------
\subsection{Overview}
%----------------------------------------

This section describes both the projection of $\Gamma_{tsp}$ to
components, and the remaining needed components to execute a
multi-stencil application. But, first the section gives an overview of
component models, and then it details \llc, the component model used in
this work.


%----------------------------------------
\subsection{Component Model Overview}
%----------------------------------------
Component model is an domain of software
engineering~\cite{Szyperski:2002:CSB:515228}, which promotes code
re-use and separations of concerns. An application is made by a set of
component; a component being a kind of black box that interacts only
through ports: ports specify the services provided and required.

Component models are known to improved code re-use, separation of
concerns, and maintainability of
applications~\cite{Szyperski:2002:CSB:515228}. More recent works have
also shown that component models can handled performance, scalability,
and portability of applications~\cite{Bernholdt01052006,
  bigot:inria-00388508, l2c}. Many component models exist, each of
them with its own specifications and singularities. In distributed
computing, well known models are CCM~\cite{corba:omg06} (CORBA
Component Model), and GCM~\cite{Baude} (Grid Component Model); in HPC,
there are CCA~\cite{Bernholdt01052006} (Common Component
Architecture), and \llc~\cite{l2c} (Low Level Component), for example.

%----------------------------------------
\subsection{\llc}
%----------------------------------------

The remaining of this paper focuses on \llc, in particular for the
experiments. Let describe it in more details.

\llc is a minimalist \texttt{C++} based HPC component model where a
component extends the concept of class by specifying in its interfaces
the services that it offers ($provide$ ports) and that it needs,
either a single service instance ($use$ ports), or multiple service
instances ($use-multiple$ ports). Services are \texttt{C++}
interfaces. \llc also offer $MPI$ ports that enable components to
share a MPI communicators.
%
As illustrated in Figures~\ref{fig:ports}, a $provide$ port is
represented by a white circle on the left of the component, a $use$
port by a black circle, a $use-multiple$ port by a black circle with a
white $m$ in it, both on the right of the component. MPI PORT!!!

A classical \llc-based application is a static \emph{assembly} of
components made of instances of component and connections between
ports. Such an assembly is describe in LAD (\llc Assembly Descriptor),
an XML dialect~\cite{l2c}.

\begin{figure}[t]
a)\hspace{2mm} \begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (C) at (0,0) {$C_0$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {};
   \node[provide,right=1.5cm of u] (p1) {};
   \node[component,right=1.5cm of p1] (C1) {$C_1$};
   \node[use,right=1.5cm of C1] (um) {$m$};
 
  \path[-]
    (p) edge node {$p$} (C)
    (C.east) edge node {$u$} (u)
    (C1)  edge node {$u'$} (um)
    (p1) edge node {$p'$} (C1);
\end{tikzpicture}
\\\\
b)\hspace{2mm}\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (C) at (0,0) {$C_0$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {};
   \node[component,right=1.5 of u] (C1) {$C_1$};
   \node[use,right=1.5 of C1] (um) {$m$};
 
  \path[-]
    (p) edge node {} (C)
    (C) edge node {} (u)
    (C1)  edge node {} (um)
    (u) edge node {} (C1);
\end{tikzpicture}
\\\\
c) MPI!!!
\\\\
\caption{a) Component $C_0$ has a provide port ($p$) and a use port ($u$); Component $C_1$ has also a provide port ($p'$) but a use multiple port ($u'$). b) When a use port is connected to a provide port, only the use port is shown and by convention it has to be the left component.}
\label{fig:ports}
\end{figure}

%% In the rest of this paper, when a required service of a \emph{use} (or \emph{use-multiple}) port is filled and linked to a \emph{provide} port in the comonent assembly, only the use port stay visible, as illustrated in Figure~\ref{fig:assembly}. As the use port is on the right of its component, and the provide port on the left, in a component assembly the component on the left uses the provide port of the component on the right.

%----------------------------------------
\subsection{Control components}
%----------------------------------------
The series-parallel tree decomposition $\Gamma_{tsp}$ represents the control of the dependencies of the simulation. As a result to be able to dump it to a component assembly it is needed to introduce what can be called \emph{control components}. Those components can be used for any case of simulation which increases code reuse between simulations. A control component is composed of a single \emph{provide} port linked to a single execution method, most of the time called the \emph{go} method. We introduce three types of control components described bellow:

\begin{itemize}
\item a sequence component, called SEQ, is the direct dump to a sequence node of $\Gamma_{tsp}$. The role of this component is to call an ordered list of other components. For this reason, it is composed of an ordered \emph{use-multiple} port connected to the components to call as a sequence.

\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (seq) at (0,0) {$SEQ$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {$m$};
 
  \path[-]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
\end{tikzpicture}

\item A parallel component, called PAR, is the direct dump to a parallel node of $\Gamma_{tsp}$. The role of this component is to call simultaneously a set of other components. For this reason, it is composed, as SEQ, of a \emph{use-multiple} port connected to the components to call in parallel.

\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (seq) at (0,0) {$PAR$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {$m$};
 
  \path[-]
    (p) edge node {} (seq)
    (seq) edge node {} (u);
\end{tikzpicture}

\item A synchronization component, called SYNC, is the direct dump to an update leaf of $\Gamma_{tsp}$. The role of this component is to call the synchronization of a given data. For this reason, it is composed of a \emph{use} port connected to the data to update.

\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (sync) at (0,0) {$SYNC$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {};
 
  \path[-]
    (p) edge node {} (sync)
    (sync) edge node {} (u);
\end{tikzpicture}
\end{itemize}

In the computation part of the simulation a final component is needed, the computation component, denoted K. This type of component represents a single computation of the simulation, i.e. the computation of a single output data (written) using a set of input data (read). Using a \emph{use-multiple}, however, a list of component is used and the explicit identification of each component to use is lost. If for SEQ or PAR, the identification of components is not usefull, it is usefull to manipulate data in a computation. For this reason a computation component has as much \emph{use} ports as input and output data to manipulate. We denote this in the bellow representation as a star on the use port.

\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   \node[component] (k) at (0,0) {$K$};
   \node[provide] (p) at (-1.5,0) {};
   \node[use] (u) at (1.5,0) {};
   \node[right=0.2 of u] (star) {*};
 
  \path[-]
    (p) edge node {} (k)
    (k) edge node {} (u);
\end{tikzpicture}


%----------------------------------------
\subsection{Dump to a component assembly}
%----------------------------------------
From $\Gamma_{tsp}$ and using the control components described above, a direct dump can be done to a component assembly for an hybrid (data and task) parallelization of a simulation. However, it is also possible to dump to a data parallelization only. In such a case the computation of $\Gamma_{data}$ is enough to generate the component assembly. Actually a single SEQ component is thus needed and this component is linked to all computations and synchronizations of $\Gamma_{data}$ directly.

As an example, from $\Gamma_{tsp}$ illustrated in Figure~\ref{fig:canon} a direct dump example is illustrated in Figure~\ref{fig:assembly}. In this Figure, the ports linked to data (use and use-multiple ports of SYNC and K) are represented but are not connected. Moreover, each computation component is an instance of the component K presented before but takes the identification name of the computation in the MSL file.

\begin{figure*}
\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto]
   %seq0
   \node[component] (seq0) at (0,0) {$SEQ$};
   \node[provide] (seq0p) [left = 0.8cm of seq0] {};
   \node[use] (seq0u) [right = 1cm of seq0] {$m$};
   %c0
   \node[component] (c0) [right = 2cm of seq0u] {$c_0$};
   \node[use] (c0u) [right = 0.8cm of c0] {};
   \node[right=0.2 of c0u] (star) {*};
   %sync0
   \node[component] (sync0) [below = 1cm of c0] {$SYNC$};
   \node[use] (sync0u) [right = 1cm of sync0] {$m$};
   %c1
   \node[component] (c1) [below = 0.8cm of sync0] {$c_1^*$};
   \node[use] (c1u) [right = 0.8cm of c1] {};
   \node[right=0.2 of c1u] (star) {*};
   %par0
   \node[component] (par0) [below = 0.8cm of c1] {$PAR$};
   \node[use] (par0u) [right = 1cm of par0] {$m$};
  %seq1
   \node[component] (seq1) [right = 1cm of par0u] {$SEQ$};
   \node[use] (seq1u) [right = 1cm of seq1] {$m$};
   %par1
   \node[component] (par1) [right = 1cm of seq1u] {$PAR$};
   \node[use] (par1u) [right = 1cm of par1] {$m$};
  %c2
   \node[component] (c2) [right = 1cm of par1u] {$c_2$};
   \node[use] (c2u) [right = 0.8cm of c2] {};
   \node[right=0.2 of c2u] (star) {*};
  %sync1
   \node[component] (sync1) [below = 0.8cm of c2] {$SYNC$};
   \node[use] (sync1u) [right = 1cm of sync1] {$m$};
  %c4
   \node[component] (c4) [below = 0.8cm of par1] {$c_4^*$};
   \node[use] (c4u) [right = 0.8cm of c4] {};
   \node[right=0.2 of c4u] (star) {*};
  %c6
   \node[component] (c6) [below = 0.8cm of c4] {$c_6$};
   \node[use] (c6u) [right = 0.8cm of c6] {};
   \node[right=0.2 of c6u] (star) {*};
  %seq2
   \node[component] (seq2) [below = 2.5cm of seq1] {$SEQ$};
   \node[use] (seq2u) [right = 1cm of seq2] {$m$};
  %c3
   \node[component] (c3) [right = 1cm of seq2u] {$c_3$};
   \node[use] (c3u) [right = 0.8cm of c3] {};
   \node[right=0.2 of c3u] (star) {*};
  %c5
   \node[component] (c5) [below = 0.8cm of c3] {$c_5$};
   \node[use] (c5u) [right = 0.8cm of c5] {};
   \node[right=0.2 of c5u] (star) {*};
  %c7
   \node[component] (c7) [below = 0.8cm of par0] {$c_7$};
   \node[use] (c7u) [right = 0.8cm of c7] {};
   \node[right=0.2 of c7u] (star) {*};
  %sync2
   \node[component] (sync2) [below = 0.8cm of c7] {$SYNC$};
   \node[use] (sync2u) [right = 1cm of sync2] {$m$};
  %c8
   \node[component] (c8) [below = 0.8cm of sync2] {$c_8^*$};
   \node[use] (c8u) [right = 0.8cm of c8] {};
   \node[right=0.2 of c8u] (star) {*};

   \path[-]
   %seq0
    (seq0) edge node {} (seq0u)
    (seq0p) edge node {} (seq0)
   %c0
    (seq0u) edge node {} (c0)
    (c0) edge node {} (c0u)
    %sync0
    (seq0u) edge node {} (sync0.west)
    (sync0) edge node {} (sync0u)
    %c1
    (seq0u) edge node {} (c1)
    (c1) edge node {} (c1u)
   %par0
    (seq0u) edge node {} (par0.west)
    (par0) edge node {} (par0u)
  %seq1
    (par0u) edge node {} (seq1)
    (seq1) edge node {} (seq1u)
  %par1
    (seq1u) edge node {} (par1.west)
    (par1) edge node {} (par1u)
  %c2
    (par1u) edge node {} (c2)
    (c2) edge node {} (c2u)
  %sync0
    (par1u) edge node {} (sync1.west)
    (sync1) edge node {} (sync1u)
  %c4
    (seq1u) edge node {} (c4.west)
    (c4) edge node {} (c4u)
  %c6
    (seq1u) edge node {} (c6.west)
    (c6) edge node {} (c6u)
  %seq2
    (par0u) edge node {} (seq2.west)
    (seq2) edge node {} (seq2u)
  %c3
    (seq2u) edge node {} (c3)
    (c3) edge node {} (c3u)
  %c6
    (seq2u) edge node {} (c5.west)
    (c5) edge node {} (c5u)
  %c6
    (seq0u) edge node {} (c7.west)
    (c7) edge node {} (c7u)
  %sync2
    (seq0u) edge node {} (sync2.west)
    (sync2) edge node {} (sync2u)
  %c8
    (seq0u) edge [bend right] node {} (c8.west)
    (c8) edge node {} (c8u)
   ;
\end{tikzpicture}
\caption{Direct dump to a component assembly.}
\label{fig:assembly}
\end{center}
\end{figure*}
