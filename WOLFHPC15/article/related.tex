% %----------------------------------------
% \subsection{Stencil solutions}
% %----------------------------------------

Many specific solutions exist to ease parallel programming of numerical simulations. Solutions such as PETSc~\cite{petsc-efficient} and Trilinos~\cite{Trilinos-Overview} are specific libraries. They are made to solve many kinds of PDEs using well-known methods and solvers which are efficiently parallelized inside the library. Those libraries also include solvers for implicit numerical schemes, not addressed in this work. However, using those solutions the user has to use and follow existing tools. In other words, it is not possible for a mathematician or a physician to write his own numerical method if it differs from existing ones. Moreover as PETSc and Trilinos are libraries they do not propose a domain specific language to define computations. The purpose of those solutions are much more specific than our solution.
\todo[inline]{JB: j'utiliserais plutot le terme "framework" que "library"}

Other solutions try to take a step back in the abstraction to propose a way to hide parallel codes for stencils while keeping a sequential programming style. For example PATUS~\cite{citeulike12258902} and Pochoir~\cite{spaaTangCKLL11} are proposed to write stencil codes for general structured meshes, and OP2~\cite{Giles2011} and Liszt~\cite{DeVito2011LDS} for general unstructured meshes. Those solutions can be considered as stencil compilers. Actually they produce optimized (cache tiling etc.) or parallel (CUDA, OpenCL etc.) codes for a single stencil computation.
Recently, domain specific languages for very specific numerical methods such as ExaSlang~\cite{Schmitt:2014:EDL:2691166.2691171} for multigrid solvers, and OPS~\cite{Reguly:2014:ODS:2691166.2691173} for meshes of structured meshes (hybrid mesh) have also been proposed. 
All those solutions are powerful, let the user implement their own stencil codes in a sequential programming style, and produce high performance codes for shared memory architectures and sometimes distributed memory architectures. 

Most stencil compilers handle the parallelization or the optimization of a single stencil kernel, considering that it represent the main computation time of numerical simulations. However, many real case numerical simulation are not composed of a single stencil kernel, as explained in Section~\ref{sect:multistencil}, but of more than one stencil computation, involving one or more stencil shapes, and additional local computations. Solutions like Pochoir or PATUS handle the parallelization or the optimization of a single stencil code, considering that stencil codes represent the main computation time of numerical simulations. Liszt~\cite{DeVito2011LDS} is the closest solution to our work as it seems to take into account the entire program and not only stencil kernels. 

The work presented in this paper takes place at a different level of numerical simulations and can be seen as complementary to stencil compilers. Actually, the MSL language is agnostic and should work for any type of mesh and any neighborhood shape in stencil codes. The MSC part of the compiler only needs this agnostic description of the overall simulation to generate a parallel pattern of the program, which needs to be filled with computation codes. Thus, depending on the underlying distributed data structure used, those computation codes could be generated by stencil compilers. As a result, MSL and its compiler are not a new contribution to compile optimized stencil codes, but propose another level of parallelization and a different approach of back-end solution.

% %----------------------------------------
% \subsection{Language, control and component models}
% %----------------------------------------

% \textbf{Put it somewhere else !}

% As far as we know, no existing DSL has been transformed to a HPC component assembly until know. This paper is a contribution to study the interest of using component models to increase code re-use, separation of concerns and maintainability in DSLs. Actually, as the code is not generated inside the DSL itself but is built from the assembly of existing components, many advantages can get out of this work. First, the code-reuse from one DSL to another is increased if the components are well studied and defined. For example, it seems that control components introduced in this paper can be used for many different DSLs in many different domains. Second, separation of concerns in the final code is also improved as the generated component assembly split the different functionalities of the application in different components. As a result, some components can be written by computer-scientists, while other are specific to the application, as for example computation components. Finally, the maintainability of the application is also increased, as each functionality is separated. In the final code if a computation component has to be modified by a numerician, intricate part of the code will be unchanged and not seen by the numerician.

% If the study of a DSL dumped to a component assembly has not been studied until now, some component models have already proposed the introduction of time control and data control in the assembly, as for example STCM~\cite{DBLP:confeuropar2008} and XMan~\cite{He12component-baseddesign}. However, both those solutions does not seem to target high performance computing and distributed components.
